{"version":3,"sources":["../node_modules/browser-pack/_prelude.js","core/JsInterop/ObservableApi/mutationObserver.ts","core/JsInterop/ObservableApi/observableApi.ts","core/JsInterop/ObservableApi/resizeObserver.ts","core/JsInterop/interop.ts","core/JsInterop/modules/components/backtopHelper.ts","core/JsInterop/modules/components/export.ts","core/JsInterop/modules/components/iconHelper.ts","core/JsInterop/modules/components/inputHelper.ts","core/JsInterop/modules/components/mentionsHelper.ts","core/JsInterop/modules/components/modalHelper.ts","core/JsInterop/modules/components/overlay.ts","core/JsInterop/modules/components/overlayHelper.ts","core/JsInterop/modules/components/tableHelper.ts","core/JsInterop/modules/components/uploadHelper.ts","core/JsInterop/modules/dom/dragHelper.ts","core/JsInterop/modules/dom/eventHelper.ts","core/JsInterop/modules/dom/exports.ts","core/JsInterop/modules/dom/infoHelper.ts","core/JsInterop/modules/dom/manipulationHelper.ts","core/JsInterop/modules/dom/types.ts","core/JsInterop/modules/enums.ts","core/JsInterop/modules/stateProvider.ts","core/JsInterop/modules/styleHelper.ts","main.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","infoHelper_1","mutationObserver","key","invoker","observer","arguments","undefined","MutationObserver","mutations","observerCallback","mutationObservers","set","element","options","get","domElement","infoHelper","observe","this","disconnect","delete","entriesJson","JSON","stringify","invokeMethodAsync","Map","resizeObserver_1","Object","defineProperty","enumerable","resizeObserver","mutationObserver_1","ResizeObserverEntry","window","ResizeObserver","entries","observerCallBack","resizeObservers","unobserve","mappedEntries","Array","forEach","entry","mEntry","borderBoxSize","blockSize","inlineSize","contentBoxSize","contentRect","x","y","width","height","top","right","bottom","left","target","push","stateProvider_1","state","observable","exports_1","domInfoHelper","domTypes","domManipulationHelper","eventHelper","styleHelper_1","styleHelper","export_1","backtopHelper","iconHelper","inputHelper","mentionsHelper","modalHelper","overlayHelper","tableHelper","uploadHelper","dragHelper_1","enableDraggable","disableDraggable","resetModalPosition","log","text","console","dom","slideTo","scrollTop","backtopHelper_1","overlayHelper_1","uploadHelper_1","mentionsHelper_1","modalHelper_1","inputHelper_1","tableHelper_1","iconHelper_1","scriptUrl","script","document","querySelector","createElement","setAttribute","body","appendChild","observableApi_1","result","scrollHeight","currentStyle","parseFloat","getComputedStyle","defaultView","getPropertyValue","is","NaN","minRows","maxRows","objReference","objReferenceDict","id","eventCallbackRegistry","resizeTextArea","addEventListener","resize","create","style","getTextAreaInfo","disposeResizeTextArea","removeEventListener","dims","rowHeight","offsetHeight","oldHeight","oldRows","rows","Math","trunc","newHeight","max","overflowY","scrollWidth","position","value","selectionStart","selectionEnd","mentionsOnWindowClick","offset","getOffset","elem","InputCaret","mentionsObj","inputor","_classCallCheck","getPos","domInputor","getPosition","pos","format","replace","test","navigator","userAgent","inputorValue","start_range","slice","end_range","html","Mirror","rect","getBoundingClientRect","scrollLeft","$mirror","AntDesign","interop","css","mirrorCss","innerHTML","parentElement","append","_this","zIndex","css_attr","flag","oRect","offsetLeft","offsetTop","removeChild","selector","htmlElement","count","ele","hasAttribute","activeElement","blur","setTimeout","focus","getActiveElement","focusDialog","querySelectorAll","parentNode","Placement","TriggerBoundyAdjustMode","end","overlay","className","indexOf","start","lastIndexOf","substr","classList","remove","isContainerBody","scrollbarSize","horizontalHeight","innerHeight","documentElement","clientHeight","verticalWidth","innerWidth","clientWidth","container","offsetWidth","blazorId","resizing","bind","trigger","mutating","attributes","characterData","childList","subtree","attributeOldValue","characterDataOldValue","onScroll","diff","isTriggerFixed","lastScrollPosition","pageYOffset","Overlay","reversePositionValue","containerInfo","overlayInfo","selectedVerticalPosition","sanitizedPosition","getAdjustedBottom","calculatePosition","overlayPreset","duringInit","lastStyleMutation","cssText","dispose","contains","applyLocation","firstTime","offsetParent","recentPlacement","placement","getKeyElementDimensions","restoreInitialPlacement","calculationsToPerform","getNominalPositions","size","adjustToContainerBoundaries","sanitizeCalculatedPositions","triggerPrefixCls","add","assign","getMaxZIndex","selectedHorizontalPosition","getAdjustedRight","containerBoundarySize","getContainerBoundarySize","directionsToCalculate","Set","boundyAdjustMode","None","horizontalPosition","getHorizontalPosition","verticalPosition","getVerticalPosition","initialPlacement","appliedStylePositionMap","horizontal","vertical","verticalCalculation","setVerticalCalculation","horizontalCalculation","setHorizontalCalculation","info","parentInfo","containerId","absoluteTop","triggerInfo","absoluteLeft","triggerHtml","outerHTML","class","appliedCssPosition","overlay_style_top","overlay_style_bottom","overlay_style_left","overlay_style_right","pageXOffset","containerIsBody","scrollbars","overlayConstraints","placment","applyPlacement","currentPlacement","newPlacement","stringMach","getInfo","calculateScrollBarSizes","triggerPosition","clientTop","clientLeft","has","adjustVerticalToContainerBoundaries","adjustHorizontalToContainerBoundaries","getWindow","scroll","getScroll","bodyBoundarySize","InScroll","setBodyBoundayrSize","parentIsInsignificant","verticalScrollBasedOnParent","horizontalScrollBasedOnParent","visibleIn","boundary","positionCache","selectedPositionCache","placementCache","horizontalCalculationCache","visibleWidthBeforeAdjustment","visibleWidthInBodyBeforeAdjustment","visibleWidthAfterAdjustment","visibleWidthInBodyAfterAdjustment","overlayFitsContainer","getOverlayVisibleWidth","isContainerOverBody","getHorizontalAdjustment","verticalCalculationCache","visibleHeightBeforeAdjustment","visibleHeightInBodyBeforeAdjustment","visibleHeightAfterAdjustment","visibleHeightInBodyAfterAdjustment","getOverlayVisibleHeight","getVerticalAdjustment","type","endExpressedAsLeft","endExpressedAsTop","reverseVerticalPlacementMap","reverseHorizontalPlacementMap","triggerIsWrappedInDiv","childNodes","childElement","LeftTop","RightTop","triggerTop","triggerHeight","overlayHeight","constraints","BottomLeft","BottomCenter","Bottom","BottomRight","verticalOffset","Left","Right","TopLeft","TopCenter","Top","TopRight","triggerBottom","LeftBottom","RightBottom","triggerLeft","triggerWidth","overlayWidth","horizontalOffset","triggerRight","containerDimension","overlayDimension","triggerBoundyAdjustMode","findAncestorWithZIndex","removeHiddenClass","getFirstValidChild","arrowPointAtCenter","arrowCenterPlacementMatch","isFixedPosition","overlay_1","overlaySelector","triggerSelector","containerSelector","overlayTop","overlayLeft","overlayElement","containerElement","triggerElement","addElementTo","overlayPresets","overlayRegistry","addOverlayToContainer","preventKeyOnCondition","bodyRef","tableRef","headerRef","scrollX","scrollY","bindScroll","SetScrollPositionClassName","pingLeft","pingRight","abs","btn","fileClickEvent","stopPropagation","fileId","currentTarget","nodeValue","getElementById","click","files","fileInfo","file","objectUrl","getObjectURL","fileName","name","objectURL","url","URL","createObjectURL","webkitURL","index","data","headers","instance","percentMethod","successMethod","errorMethod","method","formData","FormData","req","XMLHttpRequest","onreadystatechange","readyState","status","responseText","upload","onprogress","event","percent","floor","loaded","onerror","open","header","setRequestHeader","send","throttle","fn","threshold","timeout","Date","_len","args","_key","curTime","clearTimeout","apply","eventMap","defaultOptions","inViewport","Dragger","_container","_trigger","_options","onMousedown","onMouseup","onMousemove","onResize","_style","_isFirst","dragInViewport","_this2","_state","isInDrag","mX","clientX","mY","clientY","_getContainerPos","getContainerPos","domMaxY","domMaxX","getAttribute","domStartX","domStartY","_getContainerPos2","newDomX","nowX","nowY","disX","disY","newDomY","margin","paddingBottom","parseInt","dragger","bindDrag","unbindDrag","resetContainerStyle","eventType","eventName","evt","createEvent","initEvent","dispatchEvent","preventDefault","callback","k","obj","json","v","Node","Window","debounce","firstElementChild","addDomEventListener","inputElement","keys","map","toUpperCase","preventKeys","check","func","wait","immediate","_arguments","context","callNow","manipulationHelper_1","manipulationHelper","eventHelper_1","absolutePosition","getElementAbsolutePos","round","box","res","viewportElement","innerText","concat","_toConsumableArray","reduce","node","nodeName","toLowerCase","zIndexAsString","Number","isNaN","enums","addElement","elementSelector","parent","delElement","clipboard","writeText","then","err","error","fallbackCopyTextToClipboard","textArea","select","msg","execCommand","noScroll","option","FocusBehavior","FocusAtLast","HTMLElement","preventScroll","HTMLInputElement","HTMLTextAreaElement","FocusAndSelectAll","FocusAtFirst","setSelectionRange","scrollIntoView","behavior","block","inline","targetPageY","timer","setInterval","currentY","speed","ceil","clearInterval","scrollTo","currInput","tagName","inputs","getElementsByTagName","next","oldBodyCache","oldBodyCacheStack","hasScrollbar","overflow","addCls","pop","_a","_b","_c","removeCls","objReferenceName","State","getInstance","_element$classList","clsName","_element$classList2","query","matchMedia","matches","styleProp","setProperty","cssAttributes","split","cssAttribute","attribute","hasOwnProperty"],"mappings":"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","file":"ant-design-blazor.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","﻿import { infoHelper as domInfoHelper } from '../modules/dom/infoHelper';\n\nexport class mutationObserver {\n  // @ts-ignore: TS2304: Cannot find name 'MutationObserver'\n  private static mutationObservers: Map<string, MutationObserver> = new Map<string, MutationObserver>();\n\n\n  static create(key: string, invoker, isDotNetInvoker: boolean = true) {\n    // @ts-ignore: TS2304: Cannot find name 'MutationObserver'\n    let observer;\n\n    if (isDotNetInvoker) {\n      observer = new MutationObserver(mutations => mutationObserver.observerCallback(mutations, invoker))\n    } else {\n      observer = new MutationObserver(mutations => invoker(mutations))\n    }\n    mutationObserver.mutationObservers.set(key, observer)\n  }\n\n  static observe(key: string, element, options?: MutationObserverInit) {\n    const observer = mutationObserver.mutationObservers.get(key);\n    if (observer) {\n      let domElement = domInfoHelper.get(element);\n      observer.observe(domElement, options);\n    }\n  }\n\n  static disconnect(key: string): void {\n    const observer = this.mutationObservers.get(key)\n    if (observer) {\n      observer.disconnect()\n    }\n  }\n\n  static dispose(key: string): void {\n    this.disconnect(key)\n    this.mutationObservers.delete(key)\n  }\n\n  private static observerCallback(mutations, invoker) {\n    //TODO: serialize a proper object (check resizeObserver.ts for sample)\n    const entriesJson = JSON.stringify(mutations)\n    invoker.invokeMethodAsync('Invoke', entriesJson)\n  }\n}","﻿export { resizeObserver as resize } from './resizeObserver';\nexport { mutationObserver } from './mutationObserver';","﻿import { infoHelper as domInfoHelper} from '../modules/dom/infoHelper';\nimport { boxSize, domRect } from '../modules/dom/types';\n\nclass ResizeObserverEntry {\n  borderBoxSize?: boxSize\n  contentBoxSize?: boxSize\n  contentRect?: domRect\n  target?: Element\n}\n\nexport class resizeObserver {\n\n  static isResizeObserverSupported(): boolean {\n    return \"ResizeObserver\" in window;\n  }\n\n  // @ts-ignore: TS2304: Cannot find name 'ResizeObserver'\n  private static resizeObservers: Map<string, ResizeObserver> = new Map<string, ResizeObserver>();\n\n  static create(key, invoker, isDotNetInvoker: boolean = true ) {\n    // @ts-ignore: TS2304: Cannot find name 'ResizeObserver'\n    let observer;\n        \n    if (isDotNetInvoker) {\n      observer = new ResizeObserver((entries, observer) => resizeObserver.observerCallBack(entries, observer, invoker));\n    } else {\n      observer = new ResizeObserver((entries, observer) => invoker(entries, observer));\n    }\n    resizeObserver.resizeObservers.set(key, observer)\n  }\n\n  static observe(key: string, element) {\n    const observer = resizeObserver.resizeObservers.get(key);\n    if (observer) {\n      let domElement = domInfoHelper.get(element);\n      observer.observe(domElement);\n    }\n  }\n\n  static disconnect(key: string): void {\n    const observer = this.resizeObservers.get(key)\n    if (observer) {\n      observer.disconnect()\n    }\n  }\n\n  static unobserve(key: string, element: Element): void {\n    const observer = this.resizeObservers.get(key)\n\n    if (observer) {\n      let domElement = domInfoHelper.get(element);\n      observer.unobserve(domElement)\n    }\n  }\n\n  static dispose(key: string): void {\n    this.disconnect(key)\n    this.resizeObservers.delete(key)\n  }\n\n  private static observerCallBack(entries, observer, invoker) {\n    if (invoker) {\n      const mappedEntries = new Array<ResizeObserverEntry>()\n      entries.forEach(entry => {        \n        if (entry) {\n          const mEntry = new ResizeObserverEntry()\n          if (entry.borderBoxSize) {\n            mEntry.borderBoxSize = {\n              blockSize: entry.borderBoxSize.blockSize,\n              inlineSize: entry.borderBoxSize.inlineSize\n            }\n          }\n\n          if (entry.contentBoxSize) {\n            mEntry.contentBoxSize = {\n              blockSize: entry.contentBoxSize.blockSize,\n              inlineSize: entry.contentBoxSize.inlineSize\n            }\n          }\n\n          if (entry.contentRect) {\n            mEntry.contentRect = {\n              x: entry.contentRect.x,\n              y: entry.contentRect.y,\n              width: entry.contentRect.width,\n              height: entry.contentRect.height,\n              top: entry.contentRect.top,\n              right: entry.contentRect.right,\n              bottom: entry.contentRect.bottom,\n              left: entry.contentRect.left\n            }\n\n          }\n\n          mEntry.target = entry.target\n          mappedEntries.push(mEntry)\n        }\n      })\n\n      const entriesJson = JSON.stringify(mappedEntries)\n      invoker.invokeMethodAsync('Invoke', entriesJson)\n    }\n  }\n\n}","export { state } from './modules/stateProvider';\nexport * as observable from './ObservableApi/observableApi';\nexport { domInfoHelper, domTypes, domManipulationHelper, eventHelper } from './modules/dom/exports';\nexport { styleHelper } from './modules/styleHelper';\nexport {\n  backtopHelper,\n  iconHelper,\n  inputHelper,\n  mentionsHelper,\n  modalHelper,\n  overlayHelper,\n  tableHelper,\n  uploadHelper\n} from './modules/components/export'\nexport { enableDraggable, disableDraggable, resetModalPosition } from \"./modules/dom/dragHelper\";\n\nexport function log(text) {\n  console.log(text);  \n}\n","﻿import { domInfoHelper, domManipulationHelper } from '../dom/exports'\n\nexport class backtopHelper {\n  static backTop(target: string) {\n    let dom = domInfoHelper.get(target);\n    if (dom) {\n      domManipulationHelper.slideTo(dom.scrollTop);\n    } else {\n      domManipulationHelper.slideTo(0);\n    }\n  }\n}","﻿export { backtopHelper } from './backtopHelper';\nexport { overlayHelper } from './overlayHelper';\nexport { uploadHelper } from './uploadHelper';\nexport { mentionsHelper } from './mentionsHelper';\nexport { modalHelper } from './modalHelper';\nexport { inputHelper } from './inputHelper';\nexport { tableHelper } from './tableHelper';\nexport { iconHelper } from './iconHelper';","﻿export class iconHelper {\n  static createIconFromfontCN(scriptUrl) {\n    if (document.querySelector(`[data-namespace=\"${scriptUrl}\"]`)) {\n      return;\n    }\n    const script = document.createElement('script');\n    script.setAttribute('src', scriptUrl);\n    script.setAttribute('data-namespace', scriptUrl);\n    document.body.appendChild(script);\n  }\n}","﻿import { domInfoHelper } from '../dom/exports'\nimport { state } from '../stateProvider';\nimport { resize } from '../../ObservableApi/observableApi';\n\nexport class inputHelper {\n\n  static getTextAreaInfo(element) {\n    var result = {};\n    var dom = domInfoHelper.get(element);\n    if (!dom) return null;\n    result[\"scrollHeight\"] = dom.scrollHeight || 0;\n\n    if (element.currentStyle) {\n      result[\"lineHeight\"] = parseFloat(element.currentStyle[\"line-height\"]);\n      result[\"paddingTop\"] = parseFloat(element.currentStyle[\"padding-top\"]);\n      result[\"paddingBottom\"] = parseFloat(element.currentStyle[\"padding-bottom\"]);\n      result[\"borderBottom\"] = parseFloat(element.currentStyle[\"border-bottom\"]);\n      result[\"borderTop\"] = parseFloat(element.currentStyle[\"border-top\"]);\n    }\n    else if (window.getComputedStyle) {\n      result[\"lineHeight\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"line-height\"));\n      result[\"paddingTop\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"padding-top\"));\n      result[\"paddingBottom\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"padding-bottom\"));\n      result[\"borderBottom\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"border-bottom\"));\n      result[\"borderTop\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"border-top\"));\n    }\n    //Firefox can return this as NaN, so it has to be handled here like that.\n    if (Object.is(NaN, result[\"borderTop\"]))\n      result[\"borderTop\"] = 1;\n    if (Object.is(NaN, result[\"borderBottom\"]))\n      result[\"borderBottom\"] = 1;\n    return result;\n  }\n\n  static registerResizeTextArea(element: HTMLTextAreaElement, minRows: number, maxRows: number, objReference) {\n    if (!objReference) {\n      this.disposeResizeTextArea(element);\n    }\n    else {\n      state.objReferenceDict[element.id] = objReference;\n      state.eventCallbackRegistry[element.id + \"input\"] = function () { inputHelper.resizeTextArea(element, minRows, maxRows); }\n      element.addEventListener(\"input\", state.eventCallbackRegistry[element.id + \"input\"]);\n      resize.create(element.id + \"-resize\", () => {\n        inputHelper.resizeTextArea(element, minRows, maxRows);\n      }, false);\n      resize.observe(element.id + \"-resize\", element);\n      inputHelper.resizeTextArea(element, minRows, maxRows);\n      element.style.resize = 'none';\n      return this.getTextAreaInfo(element);\n    }\n  }\n\n  static disposeResizeTextArea(element: HTMLTextAreaElement) {\n    element.removeEventListener(\"input\", state.eventCallbackRegistry[element.id + \"input\"]);\n    resize.unobserve(element.id + \"-resize\", element);\n    state.objReferenceDict[element.id] = null;\n    state.eventCallbackRegistry[element.id + \"input\"] = null;\n  }\n\n  static resizeTextArea(element: HTMLTextAreaElement, minRows: number, maxRows: number) {\n    let dims = this.getTextAreaInfo(element);\n    let rowHeight = dims[\"lineHeight\"];\n    let offsetHeight = dims[\"paddingTop\"] + dims[\"paddingBottom\"] + dims[\"borderTop\"] + dims[\"borderBottom\"];\n    let oldHeight = parseFloat(element.style.height);\n    //use rows attribute to evaluate real scroll height\n    let oldRows = element.rows;\n    element.rows = minRows;\n    element.style.height = 'auto';    \n    \n    var rows = Math.trunc(element.scrollHeight / rowHeight);\n    element.rows = oldRows;\n    rows = Math.max(minRows, rows);\n    var newHeight = 0;\n    if (rows > maxRows) {\n      rows = maxRows;\n\n      newHeight = (rows * rowHeight + offsetHeight);\n      element.style.height = newHeight + \"px\";\n      element.style.overflowY = \"visible\";\n    }\n    else {\n      newHeight = rows * rowHeight + offsetHeight;\n      element.style.height = newHeight + \"px\";\n      element.style.overflowY = \"hidden\";\n    }\n    if (oldHeight !== newHeight) {\n      let textAreaObj = state.objReferenceDict[element.id];\n      textAreaObj.invokeMethodAsync(\"ChangeSizeAsyncJs\", element.scrollWidth, newHeight);\n    }\n  }\n\n  static setSelectionStart(element, position: number) {\n    if (position >= 0) {\n      let dom: HTMLInputElement = domInfoHelper.get(element);\n      if (dom) {\n        if (position <= dom.value.length) {\n          dom.selectionStart = position;\n          dom.selectionEnd = position;\n        }\n      }\n    }\n  }\n\n}","﻿import { state } from \"../stateProvider\";\n\nexport class mentionsHelper {\n\n  static getCursorXY(element, objReference) {\n    state.objReferenceDict[\"mentions\"] = objReference;\n    window.addEventListener(\"click\", this.mentionsOnWindowClick);\n\n    const offset = this.getOffset(element);\n\n    return [offset.left, offset.top + offset.height + 14];\n  }\n\n  private static getOffset(elem) {\n    return (new InputCaret(elem)).getOffset();\n  }\n\n  private static mentionsOnWindowClick(e) {\n    let mentionsObj = state.objReferenceDict[\"mentions\"];\n    if (mentionsObj) {\n      mentionsObj.invokeMethodAsync(\"CloseMentionsDropDown\");\n    } else {\n      window.removeEventListener(\"click\", this.mentionsOnWindowClick);\n    }\n  }\n\n}\n\nclass InputCaret {\n  domInputor: any;\n\n  constructor(inputor) {\n    this.domInputor = inputor;\n  }\n\n  getPos = function () {\n    return this.domInputor.selectionStart;\n  };\n\n  getPosition = function (pos) {\n    var domInputor, end_range, format, html, mirror, start_range;\n    domInputor = this.domInputor;\n\n    format = function (value) {\n      value = value.replace(/<|>|`|\"|&/g, '?').replace(/\\r\\n|\\r|\\n/g, \"<br/>\");\n      if (/firefox/i.test(navigator.userAgent)) {\n        value = value.replace(/\\s/g, '&nbsp;');\n      }\n      return value;\n    };\n    if (!pos) {\n      pos = this.getPos();\n    }\n    let inputorValue = domInputor.value;\n    start_range = inputorValue.slice(0, pos);\n    end_range = inputorValue.slice(pos);\n    html = \"<span style='position: relative; display: inline;'>\" + format(start_range) + \"</span>\";\n    html += \"<span id='caret' style='position: relative; display: inline;'>|</span>\";\n    html += \"<span style='position: relative; display: inline;'>\" + format(end_range) + \"</span>\";\n    mirror = new Mirror(domInputor);\n    return mirror.create(html).rect();\n  };\n\n  getOffset = function (pos = null) {\n    var offset, position, domInputor;\n    domInputor = this.domInputor;\n\n    var rect = domInputor.getBoundingClientRect();\n\n    offset = {\n      left: rect.left,\n      top: rect.top\n    };\n\n    position = this.getPosition(pos);\n    return offset = {\n      left: offset.left + position.left - domInputor.scrollLeft,\n      top: offset.top + position.top - domInputor.scrollTop,\n      height: position.height\n    };\n  };\n\n}\n\nclass Mirror {\n  domInputor: any;\n  css_attr: any;\n  constructor(inputor) {\n    this.domInputor = inputor;\n    this.css_attr = [];\n  }\n\n  create = function (html) {\n    this.$mirror = document.createElement(\"div\");\n    //TODO: hard coded reference, try to make it more relative\n    (<any>window).AntDesign.interop.styleHelper.css(this.$mirror, this.mirrorCss());\n\n    this.$mirror.innerHTML = html;\n    this.domInputor.parentElement.append(this.$mirror);\n\n    return this;\n  };\n\n  mirrorCss = function () {\n    var css, _this = this;\n    css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -20000\n    };\n\n    this.css_attr.push('width');\n\n    this.css_attr.forEach((p) => {\n      return css[p] = _this.domInputor.style[p]//_this.$inputor.css(p);\n    })\n\n    return css;\n  };\n\n  rect = function () {\n    var flag, pos, rect;\n    flag = this.$mirror.querySelector(\"#caret\");\n    var oRect = flag.getBoundingClientRect();\n\n    pos = {\n      left: flag.offsetLeft,\n      top: flag.offsetTop\n    }; //$flag.position();\n\n    rect = {\n      left: pos.left,\n      top: pos.top,\n      height: oRect.height\n    };\n\n    this.$mirror.parentElement.removeChild(this.$mirror)\n    return rect;\n  };\n\n}","﻿import { domInfoHelper } from '../dom/exports'\n\nexport class modalHelper {\n  static focusDialog(selector: string, count: number = 0) {\n    let ele = <HTMLElement>document.querySelector(selector);\n    if (ele) {\n      if (ele.hasAttribute(\"disabled\")) {\n        let htmlElement = <HTMLElement>document.activeElement;\n        htmlElement?.blur();\n      } else {\n        setTimeout(() => {\n          ele.focus();\n          let curId = \"#\" + domInfoHelper.getActiveElement();\n          if (curId !== selector) {\n            if (count < 10) {\n              this.focusDialog(selector, count + 1);\n            }\n          }\n        }, 10);\n      }\n    }\n  }\n\n  static destroyAllDialog() {\n    document.querySelectorAll('.ant-modal-root')\n      .forEach(e => document.body.removeChild(e.parentNode));\n  }\n}","﻿import { domInfoHelper, domTypes } from '../dom/exports'\nimport { resize } from '../../ObservableApi/observableApi';\nimport { mutationObserver as mutation } from '../../ObservableApi/mutationObserver';\n\n//Make sure the enum is identical as C# AntDesign.Placement enum\nexport enum Placement {\n  TopLeft       = 0,\n  TopCenter     = 1,\n  Top           = 2,\n  TopRight      = 3,\n  Left          = 4,\n  LeftTop       = 5,\n  LeftBottom    = 6,\n  Right         = 7,\n  RightTop      = 8,\n  RightBottom   = 9,\n  BottomLeft    = 10,\n  BottomCenter  = 11,\n  Bottom        = 12,\n  BottomRight   = 13\n}\n\n//Make sure the enum is identical as C# AntDesign.TriggerBoundyAdjustMode enum\nexport enum TriggerBoundyAdjustMode {\n  None     = 0,\n  InView   = 1,\n  InScroll = 2\n}\n\ntype verticalPosition = {\n  top?: number,\n  bottom?: number\n}\n\ntype horizontalPosition = {\n  left?: number,\n  right?: number\n}\n\nexport type overlayConstraints = {\n  verticalOffset: number,\n  horizontalOffset: number,\n  arrowPointAtCenter: boolean\n}\nexport type coordinates = {\n  top?: number,\n  bottom?: number,\n  left?: number,\n  right?: number\n}\n\n\nexport type overlayPosition = {\n  top?: number,\n  bottom?: number,\n  left?: number,\n  right?: number,\n  zIndex: number,\n  placement?: Placement,\n}\n\nexport class Overlay {\n    private static appliedStylePositionMap: Map<Placement,\n        { horizontal: \"left\" | \"right\", vertical: \"top\" | \"bottom\", class: string }> =\n    new Map([\n      [Placement.TopLeft,       { horizontal: \"left\", vertical: \"bottom\", class: \"topLeft\"  }],\n      [Placement.TopCenter,     { horizontal: \"left\", vertical: \"bottom\", class: \"topCenter\" }],\n      [Placement.Top,           { horizontal: \"left\", vertical: \"bottom\", class: \"top\" }],\n      [Placement.TopRight,      { horizontal: \"right\", vertical: \"bottom\", class: \"topRight\" }],\n      [Placement.Left,          { horizontal: \"right\", vertical: \"top\", class: \"left\" }],\n      [Placement.LeftTop,       { horizontal: \"right\", vertical: \"top\", class: \"leftTop\" }],\n      [Placement.LeftBottom,    { horizontal: \"right\", vertical: \"bottom\", class: \"leftBottom\" }],\n      [Placement.Right,         { horizontal: \"left\", vertical: \"top\", class: \"right\" }],\n      [Placement.RightTop,      { horizontal: \"left\", vertical: \"top\", class: \"rightTop\" }],\n      [Placement.RightBottom,   { horizontal: \"left\", vertical: \"bottom\", class: \"rightBottom\" }],\n      [Placement.BottomLeft,    { horizontal: \"left\", vertical: \"top\", class: \"bottomLeft\" }],\n      [Placement.BottomCenter,  { horizontal: \"left\", vertical: \"top\", class: \"bottomCenter\" }],\n      [Placement.Bottom,        { horizontal: \"left\", vertical: \"top\", class: \"bottom\" }],\n      [Placement.BottomRight,   { horizontal: \"right\", vertical: \"top\", class: \"bottomRight\" }],\n    ]);\n\n  private static reverseVerticalPlacementMap: Map<Placement, Function> =\n    new Map([\n      [Placement.TopLeft,       (position: string) => Placement.BottomLeft],\n      [Placement.TopCenter,     (position: string) => Placement.BottomCenter],\n      [Placement.Top,           (position: string) => Placement.Bottom],\n      [Placement.TopRight,      (position: string) => Placement.BottomRight],\n      [Placement.Left,          (position: string) => position === \"top\" ? Placement.LeftBottom : Placement.LeftTop],\n      [Placement.LeftTop,       (position: string) => Placement.LeftBottom],\n      [Placement.LeftBottom,    (position: string) => Placement.LeftTop],\n      [Placement.Right,         (position: string) => position === \"top\" ? Placement.RightBottom : Placement.RightTop],\n      [Placement.RightTop,      (position: string) => Placement.RightBottom],\n      [Placement.RightBottom,   (position: string) => Placement.RightTop],\n      [Placement.BottomLeft,    (position: string) => Placement.TopLeft],\n      [Placement.BottomCenter,  (position: string) => Placement.TopCenter],\n      [Placement.Bottom,        (position: string) => Placement.Top],\n      [Placement.BottomRight,   (position: string) => Placement.TopRight]\n    ]);\n    \n  private static reverseHorizontalPlacementMap: Map<Placement, Function> =\n    new Map([\n      [Placement.TopLeft,       (position: string) => Placement.TopRight],\n      [Placement.TopCenter,     (position: string) => position === \"left\" ? Placement.TopRight : Placement.TopLeft],\n      [Placement.Top,     (position: string) => position === \"left\" ? Placement.TopRight : Placement.TopLeft],\n      [Placement.TopRight,      (position: string) => Placement.TopLeft],\n      [Placement.Left,          (position: string) => Placement.Right],\n      [Placement.LeftTop,       (position: string) => Placement.RightTop],\n      [Placement.LeftBottom,    (position: string) => Placement.RightBottom],\n      [Placement.Right,         (position: string) => Placement.Left],\n      [Placement.RightTop,      (position: string) => Placement.LeftBottom],\n      [Placement.RightBottom,   (position: string) => Placement.LeftTop],\n      [Placement.BottomLeft,    (position: string) => Placement.BottomRight],\n      [Placement.BottomCenter,  (position: string) => position === \"left\" ? Placement.BottomRight : Placement.BottomLeft],\n      [Placement.Bottom,        (position: string) => position === \"left\" ? Placement.BottomRight : Placement.BottomLeft],\n      [Placement.BottomRight,   (position: string) => Placement.BottomLeft]\n    ]);    \n    \n  private static arrowCenterPlacementMatch: Map<Placement, Placement> =\n    new Map([\n      [Placement.TopLeft,       Placement.Top],\n      [Placement.TopCenter,     Placement.TopCenter],\n      [Placement.Top,           Placement.Top],\n      [Placement.TopRight,      Placement.Top],\n      [Placement.Left,          Placement.Left],\n      [Placement.LeftTop,       Placement.Left],\n      [Placement.LeftBottom,    Placement.Left],\n      [Placement.Right,         Placement.Right],\n      [Placement.RightTop,      Placement.Right],\n      [Placement.RightBottom,   Placement.Right],\n      [Placement.BottomLeft,    Placement.Bottom],\n      [Placement.BottomCenter,  Placement.BottomCenter],\n      [Placement.Bottom,        Placement.Bottom],\n      [Placement.BottomRight,   Placement.Bottom]\n    ]);   \n    \n  private blazorId: string;\n  public overlay: HTMLDivElement;\n  private container: HTMLElement;\n  private trigger: HTMLElement;\n\n  private overlayInfo: domTypes.domInfo;\n  private containerInfo: domTypes.domInfo;\n  private triggerInfo: domTypes.domInfo;\n  \n  private containerBoundarySize: coordinates;\n  private bodyBoundarySize: coordinates;\n  \n  private placement: Placement;\n  private recentPlacement: Placement;\n  private initialPlacement?: Placement;\n\n  private triggerPrefixCls: string; \n\n  private boundyAdjustMode: TriggerBoundyAdjustMode\n  public position: overlayPosition;\n  public sanitizedPosition: overlayPosition;\n  \n  private overlayPreset: domTypes.position;\n\n  private verticalCalculation:\n    (triggerPosition: number, triggerHeight: number, container: domTypes.domInfo,\n    trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints)\n      => verticalPosition;\n\n  private horizontalCalculation:\n    (triggerPosition: number, triggerWidth: number, container: domTypes.domInfo,\n    trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints)\n        => horizontalPosition;\n\n  private overlayConstraints: overlayConstraints; \n  private duringInit = true;\n  private selectedVerticalPosition: \"top\" | \"bottom\";\n  private selectedHorizontalPosition: \"left\" | \"right\";\n  private calculationsToPerform: Set<\"horizontal\"|\"vertical\">;\n\n  private triggerPosition: coordinates & { absoluteTop?: number, absoluteLeft?: number, height?: number, width?: number } = { };  \n\n  private isContainerBody: boolean;\n  private isContainerOverBody = false;\n  private isTriggerFixed: boolean; //refers to trigger or any of its parent having \"position:fixed\"\n  private lastScrollPosition: number; //used only if isTriggerFixed === true\n\n  private scrollbarSize: {\n    horizontalHeight: number,\n    verticalWidth: number\n  }  \n\n  constructor(blazorId: string,\n    overlay: HTMLDivElement, container: HTMLElement, trigger: HTMLElement, placement: Placement, \n    triggerBoundyAdjustMode: TriggerBoundyAdjustMode, triggerIsWrappedInDiv: boolean, triggerPrefixCls: string,\n    overlayConstraints: overlayConstraints) {\n    this.blazorId = blazorId;\n    this.overlay = overlay;  \n    //containerInfo & scrollbars have to be obtained here, because after\n    //removal of classes, the overlay goes to left: -9999 what causes artificial \n    //scrollbars and viewport dimensions are changing\n    this.containerInfo = domInfoHelper.getInfo(container);\n    this.container = container;\n    this.isContainerBody = container === document.body;\n    this.calculateScrollBarSizes()\n    if (!this.isContainerBody) {\n      this.isContainerOverBody = domInfoHelper.findAncestorWithZIndex(this.container) > 0;\n    }\n\n    this.overlay.style.cssText = this.overlay.style.cssText.replace(\"display: none;\", \"\");\n    this.overlay.style.top = \"0px\"; //reset to prevent scrollbars if do not exist\n    this.removeHiddenClass()\n\n    //The trigger is actually wrapping div, which can have its own dimensions (coming from styles).\n    //So, first valid HTML element is picked and if there is none, the wrapping div is set as trigger.\n    //Triggers are always wrapped in div if the <ChildElement> instead of <Unbound> is used.\n    this.trigger = Overlay.getFirstValidChild(trigger, triggerIsWrappedInDiv);\n    this.triggerPrefixCls = triggerPrefixCls;\n    if (overlayConstraints.arrowPointAtCenter){      \n      this.placement = Overlay.arrowCenterPlacementMatch.get(placement);\n    } else {\n      this.placement = placement;\n    }\n    this.initialPlacement = this.placement;\n    this.boundyAdjustMode = triggerBoundyAdjustMode;    \n    this.overlayConstraints = overlayConstraints;\n\n    this.position = { zIndex: 0 };\n    this.selectedHorizontalPosition = Overlay.appliedStylePositionMap.get(this.placement).horizontal;\n    this.selectedVerticalPosition = Overlay.appliedStylePositionMap.get(this.placement).vertical;\n\n    this.verticalCalculation = Overlay.setVerticalCalculation(this.placement, this.selectedVerticalPosition);\n    this.horizontalCalculation = Overlay.setHorizontalCalculation(this.placement, this.selectedHorizontalPosition);\n    this.isTriggerFixed = domInfoHelper.isFixedPosition(this.trigger);\n    this.observe();\n  }\n\n  static getFirstValidChild(element: HTMLElement, triggerIsWrappedInDiv: boolean): HTMLElement {\n    if (triggerIsWrappedInDiv)\n    {      \n      for(let i = 0; i < element.childNodes.length; i++) {\n        const childElement = element.childNodes[i] as HTMLElement;\n        if (childElement.innerHTML)\n          return childElement;\n      }\n    }\n    return element\n  }\n\n  static setVerticalCalculation(placement: Placement, position: \"top\" | \"bottom\") {\n    if (position === \"top\") {\n      switch (placement) {\n        case Placement.LeftTop:\n        case Placement.RightTop:          \n          return function(triggerTop: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) {               \n            return { \n              top: triggerTop,\n              bottom: Overlay.reversePositionValue(triggerTop, container.scrollHeight, overlayHeight) \n            };              \n          }; \n        case Placement.BottomLeft:\n        case Placement.BottomCenter:\n        case Placement.Bottom:\n        case Placement.BottomRight:\n          return function(triggerTop: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) { \n            const position: verticalPosition = {\n              top: triggerTop + triggerHeight + constraints.verticalOffset,\n            };\n            position.bottom = Overlay.reversePositionValue(position.top, container.scrollHeight, overlayHeight)\n            return position;\n          }; \n        case Placement.Left:\n        case Placement.Right:\n          return function(triggerTop: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) {     \n            const position: verticalPosition = { \n              top: triggerTop + (triggerHeight / 2) - (overlayHeight / 2)\n            };\n            position.bottom = Overlay.reversePositionValue(position.top, container.scrollHeight, overlayHeight)\n            return position;\n          }; \n      }\n    }    \n    if (position === \"bottom\") {\n      switch (placement) {\n        case Placement.TopLeft:\n        case Placement.TopCenter:\n        case Placement.Top:\n        case Placement.TopRight:\n          return function(triggerBottom: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) { \n            const position: verticalPosition = { \n              bottom: triggerBottom + triggerHeight + constraints.verticalOffset,\n            };\n            position.top = Overlay.reversePositionValue(position.bottom, container.scrollHeight, overlayHeight);\n            return position;\n          };           \n        case Placement.LeftBottom:\n        case Placement.RightBottom:\n          return function(triggerBottom: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) {  \n            const position: verticalPosition = { \n              bottom: triggerBottom,\n              top: Overlay.reversePositionValue(triggerBottom, container.scrollHeight, overlayHeight)\n            };            \n            return position;                               \n          };   \n      }\n    }\n    //fallback - should not happen, but to avoid crashing scenarios, revert to BottomLeft\n    console.log(\"Error: setVerticalCalculation did not match, nothing selected!!! Fallback.\", placement, position);\n    return Overlay.setVerticalCalculation(Placement.BottomLeft, \"top\");\n  }\n\n  static setHorizontalCalculation(placement: Placement, position: \"left\" | \"right\") {\n    if (position === \"left\") {\n      switch (placement) {\n        case Placement.TopLeft:\n        case Placement.BottomLeft:\n          return function(triggerLeft: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            return { \n              left: triggerLeft,\n              right: Overlay.reversePositionValue(triggerLeft, container.scrollWidth, overlayWidth)\n            };              \n          }; \n        case Placement.Right:\n        case Placement.RightTop:\n        case Placement.RightBottom:\n          return function(triggerLeft: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            const position: horizontalPosition = {\n              left: triggerLeft + triggerWidth + constraints.horizontalOffset\n            };\n            position.right = Overlay.reversePositionValue(position.left, container.scrollWidth, overlayWidth)\n            return position;\n          };\n        case Placement.TopCenter:\n        case Placement.Top:\n        case Placement.BottomCenter:\n        case Placement.Bottom:\n          return function(triggerLeft: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            const position: horizontalPosition = {\n              left: triggerLeft + (triggerWidth / 2) - (overlayWidth / 2)\n            };\n            position.right = Overlay.reversePositionValue(position.left, container.scrollWidth, overlayWidth)\n            return position;\n          };\n      }\n    }\n    if (position === \"right\") {\n      switch (placement) {\n        case Placement.TopRight:\n        case Placement.BottomRight:\n          return function(triggerRight: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            let position: horizontalPosition = {\n              right: triggerRight,\n              left: Overlay.reversePositionValue(triggerRight, container.scrollWidth, overlayWidth)\n            };            \n            return position;\n          };\n        case Placement.Left:\n        case Placement.LeftTop:\n        case Placement.LeftBottom:\n          return function(triggerRight: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {\n            const position: horizontalPosition = {\n              right: triggerRight + triggerWidth + constraints.horizontalOffset\n            };\n            position.left = Overlay.reversePositionValue(position.right, container.scrollWidth, overlayWidth)\n            return position;\n          };          \n      }      \n    }\n    //fallback - should not happen, but to avoid crashing scenarios, revert to BottomLeft\n    console.log(\"Error: setHorizontalCalculation did not match, nothing selected!!! Fallback.\", placement, position);\n    return Overlay.setVerticalCalculation(Placement.BottomLeft, \"top\");    \n  }\n\n  /**\n   * Calculates reversed position. So for given left will return right,\n   * for top => bottom, etc.\n   * @param the value that needs to be reversed (left in scenario: left => right)\n   * @param for horizontal (left, right) container width & for vertical (top, bottom) container height\n   * @param for horizontal (left, right) overlay width & for vertical (top, bottom) overlay height\n   * @returns number\n   */\n  static reversePositionValue(position: number, containerDimension: number, overlayDimension: number) {    \n    return containerDimension - position - overlayDimension;\n  }\n\n  private removeHiddenClass() {    \n    let end = this.overlay.className.indexOf(\"-hidden\");\n    let start = this.overlay.className.lastIndexOf(\" \", end)\n    if (start >= 0) {\n      let className = this.overlay.className.substr(start + 1, end);\n      if (className !== \"\") {\n        this.overlay.classList.remove(className);\n      }\n    }\n  }\n\n  private calculateScrollBarSizes() {\n    if (this.isContainerBody) {\n      this.scrollbarSize = { \n        horizontalHeight: window.innerHeight - document.documentElement.clientHeight,\n        verticalWidth: window.innerWidth - document.documentElement.clientWidth\n      }\n    } \n    else {\n      this.scrollbarSize = { \n        horizontalHeight: this.container.offsetHeight - this.container.clientHeight, \n        verticalWidth: this.container.offsetWidth - this.container.clientWidth \n      }\n    }\n  }\n\n  private observe() {\n    resize.create(`container-${this.blazorId}`, this.resizing.bind(this), false);\n    resize.observe(`container-${this.blazorId}`, this.container);    \n    resize.observe(`container-${this.blazorId}`, this.trigger);    \n    mutation.create(`trigger-${this.blazorId}`, this.mutating.bind(this), false);\n    mutation.observe(`trigger-${this.blazorId}`, this.trigger, {\n      attributes: true,\n      characterData: false,\n      childList: false,\n      subtree: false,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    \n    if (this.isContainerBody) {\n      window.addEventListener(\"scroll\", this.onScroll.bind(this));\n    }\n    else {\n      this.container.addEventListener(\"scroll\", this.onScroll.bind(this));\n    }\n  }  \n\n  private onScroll() {\n    if (this.isTriggerFixed) {\n      if (this.lastScrollPosition !== window.pageYOffset) {      \n        const diff = window.pageYOffset - this.lastScrollPosition; //positive -> down, negative -> up        \n        this.position.top += diff;\n        this.position.bottom = Overlay.reversePositionValue(this.position.top, this.containerInfo.scrollHeight, this.overlayInfo.clientHeight);      \n        if (this.selectedVerticalPosition === \"top\") {        \n          this.sanitizedPosition.top = this.position.top;\n          this.overlay.style.top = this.sanitizedPosition.top + \"px\";        \n        } else {\n          this.sanitizedPosition.bottom = this.getAdjustedBottom();\n          this.overlay.style.bottom = this.sanitizedPosition.bottom + \"px\";\n        }\n        this.lastScrollPosition = window.pageYOffset;\n      }\n    } else {\n      //Commented out code is a non-optimized calculation only if overlay stops fitting during scroll\n      //It misses active check for initialPlacement being different to current placement\n      // this.getKeyElementDimensions(false);\n      // this.containerBoundarySize = this.getContainerBoundarySize();\n      // if (!this.overlayFitsContainer(\"horizontal\", this.position.left, this.position.right)\n      //   || !this.overlayFitsContainer(\"vertical\", this.position.top, this.position.bottom)) {    \n      //     this.calculatePosition(true, false, this.overlayPreset)\n      // }    \n      this.calculatePosition(true, false, this.overlayPreset);\n    }\n  }\n\n  private resizing(entries, observer) {\n    //prevents from recalculation right on the spot during constructor run\n    if (this.duringInit) { \n      this.duringInit = false;\n      return;\n    }\n    this.calculatePosition(true, false, this.overlayPreset);\n  }\n\n  private lastStyleMutation = \"\";\n\n  /**\n   * Mutation observer will fire whenever trigger style changes. This is first and foremost\n   * to monitor position/size changes, so overlay can adjust itself to the new position.\n   * @param mutations \n   * @returns \n   */\n  private mutating(mutations) {\n    if (this.duringInit) { \n      this.duringInit = false;\n      return;\n    }    \n    if (this.lastStyleMutation !== this.trigger.style.cssText) {\n      this.lastStyleMutation = this.trigger.style.cssText;\n      this.calculatePosition(true, false, this.overlayPreset);\n    }\n    \n  }\n\n  public dispose(): void {    \n    resize.dispose(`container-${this.blazorId}`);\n    mutation.dispose(`trigger-${this.blazorId}`);\n    if (this.container.contains(this.overlay)) {\n      this.container.removeChild(this.overlay);\n    }\n\n    if (this.isContainerBody) {      \n      window.removeEventListener(\"scroll\", this.onScroll);\n    }\n    else {\n      this.container.removeEventListener(\"scroll\", this.onScroll);\n    }\n  }\n\n  public calculatePosition(applyLocation: boolean, firstTime = false, overlayPreset?: domTypes.position): overlayPosition {        \n    //check if hidden, if yes, no need to recalculate (only if not first time)\n    if (!firstTime && !this.overlay.offsetParent) {      \n      return;\n    }\n    //trigger no longer visible, hide\n    if (!overlayPreset && !this.trigger.offsetParent) {      \n      if (!this.overlay.classList.contains(this.triggerPrefixCls + \"-hidden\")) {\n        this.overlay.classList.add(this.triggerPrefixCls + \"-hidden\");\n      }\n      return this.position;\n    }\n    this.lastScrollPosition = window.pageYOffset;\n    this.recentPlacement = this.placement;\n    this.overlayPreset = overlayPreset;\n\n    this.getKeyElementDimensions(firstTime);\n\n    this.restoreInitialPlacement();\n\n    //add a very basic check - if overlay width exceeds container width, left defaults to 0     \n    this.calculationsToPerform = this.getNominalPositions();\n    if (this.calculationsToPerform.size > 0) {\n      this.adjustToContainerBoundaries();\n    }\n\n    this.sanitizeCalculatedPositions();    \n    //first positioning is applied by blazor - without it, a flicker is visible\n    if (applyLocation) {\n      this.applyLocation();\n    }    \n    return this.sanitizedPosition;\n  }\n\n  /**\n   * All variants of positions are stored during calculations, but only key positions are \n   * returned (so only left or right and only top or bottom).\n   * Also, bottom & right positions need to be recalculated, due to the fact that during \n   * calculations:\n   *  - bottom is represented as a value counting from top \n   *  - right is represented as a value counting from left\n   * Browsers use different reference for bottom & right.\n   */\n  private sanitizeCalculatedPositions() {\n    this.sanitizedPosition = { ...this.position};\n    this.sanitizedPosition.zIndex = domInfoHelper.getMaxZIndex();\n    this.sanitizedPosition.placement = this.placement;    \n    if (this.selectedHorizontalPosition === \"left\") {\n      this.sanitizedPosition.right = null;\n    }\n    else {\n      this.sanitizedPosition.left = null;\n      this.sanitizedPosition.right = this.getAdjustedRight();\n    }\n\n    if (this.selectedVerticalPosition === \"top\") {\n      this.sanitizedPosition.bottom = null;\n    }\n    else {\n      this.sanitizedPosition.top = null;\n      this.sanitizedPosition.bottom = this.getAdjustedBottom();\n    }\n  }\n\n  /**\n   * Gets first calculations of the overlay. For each direction, there is a single scenario\n   * when it is immediately known that no further calculation is needed:\n   * - for vertical direction - when overlay's height is larger than container vertical boundaries\n   * - for vertical direction - when overlay's width is larger than container horizontal boundaries\n   * These scenarios are ignored, when boundyAdjustMode === TriggerBoundyAdjustMode.None\n   * @returns collection containing directions that will be calculable (not final)\n   */\n  private getNominalPositions(): Set<\"horizontal\"|\"vertical\"> {\n    this.containerBoundarySize = this.getContainerBoundarySize();\n    const height = this.containerBoundarySize.bottom - this.containerBoundarySize.top;\n    const width = this.containerBoundarySize.right - this.containerBoundarySize.left;\n    const directionsToCalculate = new Set<\"horizontal\"|\"vertical\">();\n\n    if (this.boundyAdjustMode != TriggerBoundyAdjustMode.None && width < this.overlayInfo.clientWidth && this.isContainerBody) {\n      if (this.selectedHorizontalPosition === \"left\") {\n        this.position.left = 0;\n      } else {\n        this.position.right = 0;\n      }\n    } else {\n      const horizontalPosition = this.getHorizontalPosition();\n      this.position.left = horizontalPosition.left;\n      this.position.right = horizontalPosition.right;\n      directionsToCalculate.add(\"horizontal\");\n    }\n    //same for height exceeding container height - top defaults to 0   \n    if (this.boundyAdjustMode != TriggerBoundyAdjustMode.None && height < this.overlayInfo.clientHeight && this.isContainerBody) {      \n      if (this.selectedVerticalPosition === \"top\") {\n        this.position.top = 0;\n      } else {\n        this.position.bottom = 0;\n      }\n    } else {\n      \n      const verticalPosition = this.getVerticalPosition();\n      this.position.top = verticalPosition.top;\n      this.position.bottom = verticalPosition.bottom;      \n      directionsToCalculate.add(\"vertical\");\n    }\n    return directionsToCalculate;\n  }\n\n  /**\n   * Restore initial placement (and following connected variables & functions) on calculation.\n   * This never kicks in on first calculation. This is done because the overlay should always\n   * try to position itself to the initial placement. So on every recalculation initial settings\n   * (used during object creation) are reloaded.\n   */\n  private restoreInitialPlacement() {\n    if (this.placement !== this.initialPlacement) {\n      this.placement = this.initialPlacement;\n      this.selectedHorizontalPosition = Overlay.appliedStylePositionMap.get(this.placement).horizontal;\n      this.selectedVerticalPosition = Overlay.appliedStylePositionMap.get(this.placement).vertical;\n      this.verticalCalculation = Overlay.setVerticalCalculation(this.placement, this.selectedVerticalPosition);\n      this.horizontalCalculation = Overlay.setHorizontalCalculation(this.placement, this.selectedHorizontalPosition);\n    }\n  }\n\n  /**\n   * Very basic logging, useful during debugging.\n   * @param extraMessage \n   */\n  /* istanbul ignore next */\n  private logToConsole(extraMessage = \"\") {\n    console.log(extraMessage + \" Overlay position:\", this.position,\n      \"Input\",\n      { \n        blazorId: this.blazorId,        \n        container: {\n          info: this.containerInfo,\n          parentInfo: {\n            clientHeight: this.container.parentElement.clientHeight,\n            clientWidth: this.container.parentElement.clientWidth,\n            scrollLeft: this.container.parentElement.scrollLeft,\n            scrollTop: this.container.parentElement.scrollTop\n          },\n          containerId: this.container.id,        \n          containerBoundarySize: this.containerBoundarySize,\n        },\n        trigger: { \n          absoluteTop: this.triggerInfo.absoluteTop,\n          absoluteLeft: this.triggerInfo.absoluteLeft,\n          clientHeight: this.triggerInfo.clientHeight,\n          clientWidth: this.triggerInfo.clientWidth,\n          offsetHeight: this.triggerInfo.offsetHeight,\n          offsetWidth: this.triggerInfo.offsetWidth,\n          boundyAdjustMode: this.boundyAdjustMode,\n          //triggerType: this.triggerType,\n          triggerHtml: this.trigger.outerHTML,\n          triggerPrefixCls: this.triggerPrefixCls\n        },\n        overlay: { \n          clientHeight: this.overlayInfo.clientHeight,\n          clientWidth: this.overlayInfo.clientWidth,\n          offsetHeight: this.overlayInfo.offsetHeight,\n          offsetWidth: this.overlayInfo.offsetWidth,\n          class: this.overlay.className,\n          appliedCssPosition: {\n            overlay_style_top: this.overlay.style.top,\n            overlay_style_bottom: this.overlay.style.bottom,\n            overlay_style_left: this.overlay.style.left,\n            overlay_style_right: this.overlay.style.right\n          }\n        },\n        window: {\n          innerHeight: window.innerHeight,\n          innerWidth: window.innerWidth,\n          pageXOffset: window.pageXOffset,\n          pageYOffset: window.pageYOffset,\n        },        \n        documentElement: {\n          clientHeight: document.documentElement.clientHeight,\n          clientWidth: document.documentElement.clientWidth,\n          containerIsBody: this.isContainerBody,\n        },\n        scrollbars: this.scrollbarSize,\n        overlayPreset: this.overlayPreset,\n        overlayConstraints: this.overlayConstraints,\n        position: this.position,           \n        sanitizedPosition: this.sanitizedPosition,\n        placment: {\n         initialPlacement: this.initialPlacement,\n         recentPlacement: this.recentPlacement,\n         placement: this.placement,\n         selectedHorizontalPosition: this.selectedHorizontalPosition,\n         selectedVerticalPosition: this.selectedVerticalPosition\n        }\n      }\n    );    \n  }\n\n  /**\n   * Right in the class is calculated with assumption that it is just reversed Left. \n   * This works well for containers that are not body. When in body, then different Right \n   * calculation is executed. Example:\n   * In a document of width of 5000px, the first Left = 0 and the first Right = 0 as well \n   * (and respectively, max Left = 5000 and max Right = 5000). However, browsers are behaving \n   * differently. Left indeed is 0 until the document width (5000). Right however is different. \n   * Right = 0 means the point of original viewport most Right. So, if you viewport is 1000px \n   * wide, Right = 0 will mean same as Left = 1000. So to reach Left = 5000, Right has to \n   * be equal to -4000. \n   * @returns number - right position\n   */\n  private getAdjustedRight(): number {    \n    if (this.isContainerBody) {\n      return this.position.right - (this.containerInfo.scrollWidth - window.innerWidth)\n        - this.scrollbarSize.verticalWidth;\n    }\n    return this.position.right;    \n  }\n\n  /**\n   * Bottom in the class is calculated with assumption that it is just reversed Top. \n   * This works well for containers that are not body. When in body, then different Bottom\n   * calculation is executed. Example:\n   * In a document of height of 5000px, the first Top = 0 and the first Bottom = 0 as well \n   * (and respectively, max Top = 5000 and max Bottom = 5000). However, browsers are behaving \n   * differently. Top indeed is 0 until the document height (5000). Bottom however is different. \n   * Bottom = 0 means the point of original viewport most bottom. So, if you viewport is 1000px \n   * in height, Bottom = 0 will mean same as Top = 1000. So to reach Top = 5000, Bottom has to \n   * be equal to -4000. \n   * @returns number - bottom position\n   */\n  private getAdjustedBottom(): number {    \n    if (this.isContainerBody) {\n      return this.position.bottom - (this.containerInfo.scrollHeight - window.innerHeight)\n        - this.scrollbarSize.horizontalHeight;\n    }\n    return this.position.bottom;\n  }\n\n  private applyLocation() {\n    if (this.selectedHorizontalPosition === \"left\") {\n      this.overlay.style.left = this.sanitizedPosition.left + \"px\";\n      this.overlay.style.right = \"unset\";\n    } else {\n      this.overlay.style.right = this.sanitizedPosition.right + \"px\";\n      this.overlay.style.left = \"unset\";\n    }\n\n    if (this.selectedVerticalPosition === \"top\") {\n      this.overlay.style.top = this.sanitizedPosition.top + \"px\";\n      this.overlay.style.bottom = \"unset\";\n    } else {\n      this.overlay.style.bottom = this.sanitizedPosition.bottom + \"px\";\n      this.overlay.style.top = \"unset\";\n    }\n\n    this.applyPlacement();\n  }\n\n  private applyPlacement() {\n    if (this.recentPlacement !== this.placement) {\n      let currentPlacement: string;\n      const stringMach = `${this.triggerPrefixCls}-placement-`;\n      const start = this.overlay.className.indexOf(stringMach);\n      const end = this.overlay.className.indexOf(\" \", start + stringMach.length);\n      if (start >= 0) {\n        currentPlacement = this.overlay.className.substr(start, end-start);\n      } else {\n        currentPlacement = Overlay.appliedStylePositionMap.get(this.initialPlacement).class;\n      }\n      let newPlacement = stringMach + Overlay.appliedStylePositionMap.get(this.placement).class;\n      this.overlay.classList.replace(currentPlacement, newPlacement);\n    }\n  }\n\n  /**\n   * Loads all important dimensions of the key elements (container of the trigger, trigger & overlay)\n   * into domType.domInfo structures. This could be accessed directly, except absolute positions.\n   * Also simplifies mocking.\n   * @param firstTime - if this method is called first time, then no need to load information on\n   *  container, as it was already loaded in the constructor. This is due to the fact that first time,\n   *  when overlay is added it has default left set to -9999 which causes the scrollbars to \n   * appear (which will be gone by the time overlay becomes visible). Scrollbars change\n   *  dimensions, so often calculations were incorrect.\n   */\n  private getKeyElementDimensions(firstTime: boolean) {\n    if (!firstTime) {\n      this.containerInfo = domInfoHelper.getInfo(this.container);\n      this.calculateScrollBarSizes()\n    }    \n    this.triggerInfo = domInfoHelper.getInfo(this.trigger);\n    this.overlayInfo = domInfoHelper.getInfo(this.overlay);    \n  }\n\n  /**\n   * Calculates trigger top & bottom positions and trigger height and\n   * uses these to return nominal position values depending on placement and\n   * expected attachment point (top/bottom)\n   * @returns verticalPosition\n   */\n  private getVerticalPosition(): verticalPosition {\n    let position: verticalPosition;\n    //usually first offsetHeight is taken, as the measurement contains the borders\n    this.triggerPosition.height = this.triggerInfo.offsetHeight != 0 ? this.triggerInfo.offsetHeight \n    : this.triggerInfo.clientHeight;    \n    if (this.overlayPreset) {\n      this.triggerPosition.top = this.triggerInfo.absoluteTop + this.overlayPreset.y;\n      this.triggerPosition.height = 0;\n    } else {\n      this.triggerPosition.top = this.containerInfo.scrollTop + this.triggerInfo.absoluteTop\n        - this.containerInfo.absoluteTop - this.containerInfo.clientTop;\n    }\n    this.triggerPosition.absoluteTop = this.triggerInfo.absoluteTop;\n\n    if (this.selectedVerticalPosition === \"top\"){\n      position = this.verticalCalculation(this.triggerPosition.top, this.triggerPosition.height, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientHeight, this.overlayConstraints);\n    }\n    else { //bottom\n      this.triggerPosition.bottom = this.containerInfo.scrollHeight - this.triggerPosition.top - this.triggerPosition.height;\n      position = this.verticalCalculation(this.triggerPosition.bottom, this.triggerPosition.height, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientHeight, this.overlayConstraints);\n    }\n    return position;\n  }\n\n  /**\n   * Calculates trigger left & right positions and trigger width and\n   * uses these to return nominal position values depending on placement and\n   * expected attachment point (left/right)\n   * @returns verticalPosition\n   */\n  private getHorizontalPosition(): horizontalPosition {\n    let position: horizontalPosition;\n    //usually first offsetHeight is taken, as the measurement contains the borders    \n    this.triggerPosition.width = this.triggerInfo.offsetWidth != 0 ? this.triggerInfo.offsetWidth : this.triggerInfo.clientWidth;\n    \n    //let triggerLeft: number;\n    if (this.overlayPreset) {\n      this.triggerPosition.left = this.triggerInfo.absoluteLeft + this.overlayPreset.x;\n      this.triggerPosition.width = 0;\n    } else {\n      this.triggerPosition.left = this.containerInfo.scrollLeft + this.triggerInfo.absoluteLeft\n        - this.containerInfo.absoluteLeft - this.containerInfo.clientLeft;\n    }\n    this.triggerPosition.absoluteLeft = this.triggerInfo.absoluteLeft;\n\n    if (this.selectedHorizontalPosition === \"left\"){      \n      position = this.horizontalCalculation(this.triggerPosition.left, this.triggerPosition.width, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientWidth, this.overlayConstraints);\n    }\n    else { //right\n      this.triggerPosition.right = this.containerInfo.scrollWidth - this.triggerPosition.left - this.triggerPosition.width;\n      position = this.horizontalCalculation(this.triggerPosition.right, this.triggerPosition.width, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientWidth, this.overlayConstraints);\n    }\n    return position;    \n  }\n\n  /**\n   * Responsible for calling logic that handles situation when calculated overlay position\n   * is causing overlay to be partially rendered invisible. The goal is to adjust placement \n   * in such a way, so the overlay is fully visible.\n   * @returns void\n   */\n  private adjustToContainerBoundaries() {\n    if (this.boundyAdjustMode === TriggerBoundyAdjustMode.None) {\n      return;\n    }    \n\n    if (this.calculationsToPerform.has(\"vertical\")) {\n      this.adjustVerticalToContainerBoundaries();\n    }\n\n    if (this.calculationsToPerform.has(\"horizontal\")) {\n      this.adjustHorizontalToContainerBoundaries();\n    }\n  }\n\n  private setBodyBoundayrSize() {\n      const window = domInfoHelper.getWindow();      \n      const scroll = domInfoHelper.getScroll();\n      this.bodyBoundarySize = {\n        top : scroll.y,\n        left: scroll.x,\n        right: window.innerWidth + scroll.x,\n        bottom: window.innerHeight + scroll.y\n      };     \n  }\n\n  /**\n   * Retrieves information on current logical viewport (visible area). For \n   * InView this means actual viewport area (what you see in the browser - either the \n   * body or the scrolled to area in a container) or for InScroll this means total\n   * area of the container (or body).\n   * @returns coordinates - absolute values measuring from top = 0 and left = 0 (first \n   * pixels of the container)\n   */\n  private getContainerBoundarySize(): coordinates {    \n    if (this.boundyAdjustMode === TriggerBoundyAdjustMode.InScroll) {      \n      if (!this.isContainerBody) {\n        this.setBodyBoundayrSize();\n      }\n      return { \n          left: 0,\n          right: this.containerInfo.scrollWidth,\n          top: 0,\n          bottom: this.containerInfo.scrollHeight\n        };\n    }        \n    this.setBodyBoundayrSize();\n\n    if (this.isContainerBody) {       \n      return this.bodyBoundarySize;\n    } else {         \n      //special care is needed when evaluating viewport of the container\n      const parentIsInsignificant = this.container.parentElement.clientHeight === 0\n        || this.container.parentElement.clientWidth === 0;\n      const verticalScrollBasedOnParent = !parentIsInsignificant\n        && this.container.parentElement.clientHeight < this.containerInfo.clientHeight;\n      const horizontalScrollBasedOnParent = !parentIsInsignificant\n        && this.container.parentElement.clientWidth < this.containerInfo.clientWidth;\n\n      let clientHeight: number;\n      let clientWidth: number;\n      let scrollTop: number;\n      let scrollLeft: number;\n\n      if (verticalScrollBasedOnParent) {\n        clientHeight = this.container.parentElement.clientHeight;\n        scrollTop = this.container.parentElement.scrollTop;\n      } else {\n        clientHeight = this.containerInfo.clientHeight;\n        scrollTop = this.containerInfo.scrollTop;\n      }\n\n      if (horizontalScrollBasedOnParent) {\n        clientWidth = this.container.parentElement.clientWidth;clientWidth;\n        scrollLeft = this.container.parentElement.scrollLeft;\n      } else {\n        clientWidth = this.containerInfo.clientWidth;\n        scrollLeft = this.containerInfo.scrollLeft;\n      }\n          \n      return { \n        top : scrollTop,\n        bottom: scrollTop + clientHeight,\n        left: scrollLeft,\n        right: scrollLeft + clientWidth\n      };                \n    }  \n  }\n\n  /**\n   * Returns how much height of the overlay is visible in current viewport \n   */\n  private getOverlayVisibleHeight(visibleIn: \"container\" | \"body\"): number {\n    let boundary: coordinates;\n    let top: number;    \n    if (visibleIn === \"container\") {\n      boundary = this.containerBoundarySize;\n      top = this.triggerPosition.top;\n    } else {\n      boundary = this.bodyBoundarySize;\n      top = this.triggerPosition.absoluteTop;\n    }\n\n    if (this.selectedVerticalPosition === \"top\") {\n      return boundary.bottom - (top + this.triggerPosition.height);\n    } else {\n      return top - boundary.top;\n    }    \n  }\n\n  /**\n   * Returns how much width of the overlay is visible in current viewport \n   */\n  private getOverlayVisibleWidth(visibleIn: \"container\" | \"body\"): number {    \n    let boundary: coordinates;\n    let left: number;    \n    if (visibleIn === \"container\") {\n      boundary = this.containerBoundarySize;\n      left = this.triggerPosition.left;\n    } else {\n      boundary = this.bodyBoundarySize;\n      left = this.triggerPosition.absoluteLeft;\n    }\n\n    if (this.selectedHorizontalPosition === \"left\") {\n      return boundary.right - (left + this.triggerPosition.width);\n    } else {\n      return left - boundary.left;\n    }\n  }\n\n  /**\n   * Checks if current position actually fits in the container and if not, then reverses\n   * the placement. Then calculates which already calculated placements has the largest horizontal \n   * area of the overlay visible and picks the calculation with largest area.\n   */\n  private adjustHorizontalToContainerBoundaries() {\n    if (!this.overlayFitsContainer(\"horizontal\", this.position.left, this.position.right)) {\n      const positionCache: overlayPosition = { ...this.position };\n      const selectedPositionCache = this.selectedHorizontalPosition;\n      const placementCache = this.placement;\n      const horizontalCalculationCache = this.horizontalCalculation;\n      const visibleWidthBeforeAdjustment = this.getOverlayVisibleWidth(\"container\");\n      let visibleWidthInBodyBeforeAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleWidthInBodyBeforeAdjustment = this.getOverlayVisibleWidth(\"body\");\n      } else {\n        visibleWidthInBodyBeforeAdjustment = visibleWidthBeforeAdjustment\n      };      \n\n      this.getHorizontalAdjustment();\n\n      const visibleWidthAfterAdjustment = this.getOverlayVisibleWidth(\"container\");\n      let visibleWidthInBodyAfterAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleWidthInBodyAfterAdjustment = this.getOverlayVisibleWidth(\"body\");\n      } else {\n        visibleWidthInBodyAfterAdjustment = visibleWidthAfterAdjustment\n      };        \n\n      if (\n        !(visibleWidthInBodyBeforeAdjustment < visibleWidthInBodyAfterAdjustment \n          && visibleWidthInBodyAfterAdjustment > 0\n          && visibleWidthInBodyAfterAdjustment - visibleWidthInBodyBeforeAdjustment >= 0)        \n        ||\n        !(visibleWidthBeforeAdjustment < visibleWidthAfterAdjustment && visibleWidthAfterAdjustment > 0)) {        \n        this.position = positionCache;\n        this.selectedHorizontalPosition = selectedPositionCache;\n        this.placement = placementCache;\n        this.horizontalCalculation = horizontalCalculationCache;\n      }\n    }\n  }\n\n  /**\n   * Checks if current position actually fits in the container and if not, then reverses\n   * the placement. Then calculates which already calculated placements has the largest vertical \n   * area of the overlay visible and picks the calculation with largest area.\n   */\n  private adjustVerticalToContainerBoundaries() {\n    if (!this.overlayFitsContainer(\"vertical\", this.position.top, this.position.bottom)) {\n      const positionCache: overlayPosition = { ...this.position };\n      const selectedPositionCache = this.selectedVerticalPosition;\n      const placementCache = this.placement;\n      const verticalCalculationCache = this.verticalCalculation;\n      const visibleHeightBeforeAdjustment = this.getOverlayVisibleHeight(\"container\");\n      let visibleHeightInBodyBeforeAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleHeightInBodyBeforeAdjustment = this.getOverlayVisibleHeight(\"body\");\n      } else {\n        visibleHeightInBodyBeforeAdjustment = visibleHeightBeforeAdjustment\n      };\n\n      this.getVerticalAdjustment();      \n\n      const visibleHeightAfterAdjustment = this.getOverlayVisibleHeight(\"container\");\n      let visibleHeightInBodyAfterAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleHeightInBodyAfterAdjustment = this.getOverlayVisibleHeight(\"body\");\n      } else {\n        visibleHeightInBodyAfterAdjustment = visibleHeightAfterAdjustment\n      };          \n\n      if (\n        !(visibleHeightInBodyBeforeAdjustment < visibleHeightInBodyAfterAdjustment \n          && visibleHeightInBodyAfterAdjustment > 0 \n          && visibleHeightInBodyAfterAdjustment - visibleHeightInBodyBeforeAdjustment >= 0)\n        ||\n        !(visibleHeightBeforeAdjustment < visibleHeightAfterAdjustment && visibleHeightAfterAdjustment > 0)) {        \n        this.position = positionCache;\n        this.selectedVerticalPosition = selectedPositionCache;\n        this.placement = placementCache;\n        this.verticalCalculation = verticalCalculationCache;\n      }\n    }\n  }\n\n  private overlayFitsContainer(type: \"horizontal\" | \"vertical\", start: number, end: number): boolean {    \n    if (type === \"horizontal\") {\n      const endExpressedAsLeft = start + this.overlayInfo.clientWidth;\n      return this.containerBoundarySize.left <= start\n          && start <= this.containerBoundarySize.right //overlay left is between container left and right\n          && this.containerBoundarySize.left <= endExpressedAsLeft\n          && endExpressedAsLeft <= this.containerBoundarySize.right //and overlay right is between container left and right\n    }\n    const endExpressedAsTop = start + this.overlayInfo.clientHeight;\n    return this.containerBoundarySize.top <= start\n        && start <= this.containerBoundarySize.bottom //overlay top is between container top and bottom\n        && this.containerBoundarySize.top <= endExpressedAsTop \n        && endExpressedAsTop <= this.containerBoundarySize.bottom //and overlay bottom is between container top and bottom\n  }\n\n  /**\n   * Applies basic adjustment - switches verticaly placement (top -> bottom & bottom -> top) \n   * and recalculates based on the newly set placement \n   */\n  private getVerticalAdjustment() {\n    this.placement = Overlay.reverseVerticalPlacementMap.get(this.placement)(this.selectedVerticalPosition);\n    this.selectedVerticalPosition = Overlay.appliedStylePositionMap.get(this.placement).vertical;\n    this.verticalCalculation = Overlay.setVerticalCalculation(this.placement, this.selectedVerticalPosition);\n    const verticalPosition = this.getVerticalPosition();\n    this.position.top = verticalPosition.top;\n    this.position.bottom = verticalPosition.bottom;\n  }\n\n  /**\n   * Applies basic adjustment - switches horizontal placement (left -> right & right -> left)\n   * and recalculates based on the newly set placement\n   */\n  private getHorizontalAdjustment() {\n    this.placement = Overlay.reverseHorizontalPlacementMap.get(this.placement)(this.selectedHorizontalPosition);\n    this.selectedHorizontalPosition = Overlay.appliedStylePositionMap.get(this.placement).horizontal;\n    this.horizontalCalculation = Overlay.setHorizontalCalculation(this.placement, this.selectedHorizontalPosition);\n    const horizontalPosition = this.getHorizontalPosition();\n    this.position.left = horizontalPosition.left;\n    this.position.right = horizontalPosition.right;    \n  }  \n}","﻿import { domInfoHelper, eventHelper, domManipulationHelper, domTypes } from '../dom/exports'\nimport { Placement, TriggerBoundyAdjustMode, overlayConstraints, overlayPosition, Overlay } from './overlay'\nimport { state } from '../stateProvider';\n\nexport class overlayHelper {\n  static overlayRegistry: { [key: string]: Overlay} = {};\n\n  static addOverlayToContainer(blazorId: string, \n    overlaySelector, triggerSelector, placement: Placement,  containerSelector: string,\n    triggerBoundyAdjustMode: TriggerBoundyAdjustMode, triggerIsWrappedInDiv: boolean, triggerPrefixCls: string,\n    verticalOffset: number, horizontalOffset: number, arrowPointAtCenter: boolean,    \n    overlayTop?: number, overlayLeft?: number\n  ): overlayPosition {      \n    const overlayElement = domInfoHelper.get(overlaySelector) as HTMLDivElement;    \n    const containerElement = domInfoHelper.get(containerSelector) as HTMLElement;\n    const triggerElement = domInfoHelper.get(triggerSelector) as HTMLElement;    \n\n    if (!domManipulationHelper.addElementTo(overlaySelector, containerElement)) {\n      console.log(\"Failed to add overlay. Details:\", {\n         triggerPrefixCls: triggerPrefixCls,\n         overlaySelector: overlaySelector,\n         containerElement: containerElement\n      } );\n      return null;\n    }    \n\n    let overlayPresets: domTypes.position;\n    if (overlayTop || overlayLeft) {\n      overlayPresets = { x: overlayLeft, y: overlayTop };\n    }\n\n    const overlayConstraints: overlayConstraints = {\n      verticalOffset: verticalOffset,\n      horizontalOffset: horizontalOffset,\n      arrowPointAtCenter: arrowPointAtCenter\n    };\n\n    const overlay = new Overlay(blazorId, overlayElement, containerElement, triggerElement, placement, triggerBoundyAdjustMode, triggerIsWrappedInDiv, triggerPrefixCls, overlayConstraints);   \n    //register object in store, so it can be retrieved during update/dispose\n    this.overlayRegistry[blazorId] = overlay;\n    \n    return overlay.calculatePosition(false, true, overlayPresets);\n  }\n\n\n  static updateOverlayPosition(blazorId: string, overlaySelector, triggerSelector, placement: Placement,  containerSelector: string,\n    triggerBoundyAdjustMode: TriggerBoundyAdjustMode, triggerIsWrappedInDiv: boolean, triggerPrefixCls: string,\n    verticalOffset: number, horizontalOffset: number, arrowPointAtCenter: boolean,  \n    overlayTop?: number, overlayLeft?: number): overlayPosition {\n    const overlay = this.overlayRegistry[blazorId];\n    if (overlay){\n      let overlayPresets: domTypes.position;\n        if (overlayTop || overlayLeft) {\n          overlayPresets = { x: overlayLeft, y: overlayTop };\n        }      \n      return overlay.calculatePosition(false, false, overlayPresets);      \n    } else {\n      //When page is slow, it may happen that rendering of an overlay may not happen, even if \n      //blazor thinks it did happen. In such a case, when overlay object is not found, just try\n      //to render it again.\n      return overlayHelper.addOverlayToContainer(blazorId, overlaySelector, triggerSelector, placement,  containerSelector,triggerBoundyAdjustMode, triggerIsWrappedInDiv, triggerPrefixCls, \n      verticalOffset, horizontalOffset, arrowPointAtCenter,  \n      overlayTop, overlayLeft);      \n    }    \n  }\n\n  static deleteOverlayFromContainer(blazorId: string) {\n    const overlay = this.overlayRegistry[blazorId];\n    if (overlay) {      \n      overlay.dispose();\n      delete this.overlayRegistry[blazorId];\n    }\n  }\n\n  static addPreventEnterOnOverlayVisible(element, overlayElement) {\n    if (element && overlayElement) {\n      const dom: HTMLElement = domInfoHelper.get(element);\n      if (dom) {\n        state.eventCallbackRegistry[element.id + \"keydown:Enter\"] = (e) => eventHelper.preventKeyOnCondition(e, \"enter\", () => overlayElement.offsetParent !== null);\n        dom.addEventListener(\"keydown\", state.eventCallbackRegistry[element.id + \"keydown:Enter\"], false);\n      }\n    }\n  }\n\n  static removePreventEnterOnOverlayVisible(element) {\n    if (element) {\n      const dom: HTMLElement = domInfoHelper.get(element);\n      if (dom) {\n        dom.removeEventListener(\"keydown\", state.eventCallbackRegistry[element.id + \"keydown:Enter\"]);\n        state.eventCallbackRegistry[element.id + \"keydown:Enter\"] = null; \n      }\n    }\n  }\n}\n\n","﻿export class tableHelper {\n  static bindTableScroll(bodyRef, tableRef, headerRef, scrollX, scrollY) {\n    bodyRef.bindScroll = () => {\n      if (scrollX) {\n        tableHelper.SetScrollPositionClassName(bodyRef, tableRef);\n      }\n      if (scrollY) {\n        headerRef.scrollLeft = bodyRef.scrollLeft;\n      }\n    }\n    bodyRef.bindScroll();\n    bodyRef.addEventListener('scroll', bodyRef.bindScroll);\n    window.addEventListener('resize', bodyRef.bindScroll);\n  }\n\n  static unbindTableScroll(bodyRef) {\n    if (bodyRef) {\n      bodyRef.removeEventListener('scroll', bodyRef.bindScroll);\n      window.removeEventListener('resize', bodyRef.bindScroll);\n    }\n  }\n\n  static SetScrollPositionClassName(bodyRef, tableRef) {\n\n    let scrollLeft = bodyRef.scrollLeft;\n    let scrollWidth = bodyRef.scrollWidth;\n    let clientWidth = bodyRef.clientWidth;\n\n    let pingLeft = false;\n    let pingRight = false;\n\n    if ((scrollWidth == clientWidth && scrollWidth != 0)) {\n      pingLeft = false;\n      pingRight = false;\n    }\n    else if (scrollLeft == 0) {\n      pingLeft = false;\n      pingRight = true;\n    }\n    else if (Math.abs(scrollWidth - (scrollLeft + clientWidth)) <= 1) {\n      pingRight = false;\n      pingLeft = true;\n    }\n    else {\n      pingLeft = true;\n      pingRight = true;\n    }\n\n    pingLeft ? tableRef.classList.add(\"ant-table-ping-left\") : tableRef.classList.remove(\"ant-table-ping-left\");\n    pingRight ? tableRef.classList.add(\"ant-table-ping-right\") : tableRef.classList.remove(\"ant-table-ping-right\");\n  }\n}","﻿type fileInfo = {\n  fileName: string,\n  size: number,\n  objectURL: string,\n  type: string\n}\n\nexport class uploadHelper {\n  static addFileClickEventListener(btn: HTMLElement) {\n    if (btn.addEventListener) {\n      btn.addEventListener(\"click\", uploadHelper.fileClickEvent);\n    }\n  }\n\n  static removeFileClickEventListener(btn: HTMLElement) {\n    btn.removeEventListener(\"click\", uploadHelper.fileClickEvent);\n  }\n\n  private static fileClickEvent(e: MouseEvent) {\n    e.stopPropagation();\n    const fileId = (e.currentTarget as HTMLSpanElement).attributes[\"data-fileid\"].nodeValue;\n    const element = document.getElementById(fileId) as HTMLInputElement;\n    element.click();\n  }\n\n  static clearFile(element) {\n    element.setAttribute(\"type\", \"input\");\n    element.value = '';\n    element.setAttribute(\"type\", \"file\");\n  }\n\n  static getFileInfo(element: HTMLInputElement) {\n    if (element.files && element.files.length > 0) {\n      let fileInfo = Array<fileInfo>();\n      for (var i = 0; i < element.files.length; i++) {\n        let file = element.files[i];\n        const objectUrl = this.getObjectURL(file);\n        fileInfo.push({\n          fileName: file.name,\n          size: file.size,\n          objectURL: objectUrl,\n          type: file.type\n        });\n      }\n\n      return fileInfo;\n    }\n  }\n\n  private static getObjectURL(file: File): string {\n    var url = null;\n    if (window.URL != undefined) {\n      url = window.URL.createObjectURL(file);\n    } else if (window.webkitURL != undefined) {\n      url = window.webkitURL.createObjectURL(file);\n    }\n    return url;\n  }\n\n  static uploadFile(element, index, data, headers, fileId, url, name, instance, percentMethod, successMethod, errorMethod, method: string) {\n    let formData = new FormData();\n    var file = element.files[index];\n    var size = file.size;\n    formData.append(name, file);\n    if (data != null) {\n      for (var key in data) {\n        formData.append(key, data[key]);\n      }\n    }\n    const req = new XMLHttpRequest()\n    req.onreadystatechange = function () {\n      if (req.readyState === 4) {\n        // #1655 Any 2xx response code is okay\n        if (req.status < 200 || req.status > 299) {\n          instance.invokeMethodAsync(errorMethod, fileId, `{\"status\": ${req.status}}`);\n          return;\n        }\n        instance.invokeMethodAsync(successMethod, fileId, req.responseText);\n      }\n    }\n    req.upload.onprogress = function (event) {\n      var percent = Math.floor(event.loaded / size * 100);\n      instance.invokeMethodAsync(percentMethod, fileId, percent);\n    }\n    req.onerror = function (e) {\n      instance.invokeMethodAsync(errorMethod, fileId, \"error\");\n    }\n    req.open(method, url, true)\n    if (headers != null) {\n      for (var header in headers) {\n        req.setRequestHeader(header, headers[header]);\n      }\n    }\n    req.send(formData)\n  }\n}","﻿\nconst throttle = (fn, threshold = 160) => {\n    let timeout;\n    var start = +new Date;\n    return function (...args) {\n        let context = this, curTime = +new Date() - 0;\n        //总是干掉事件回调\n        window.clearTimeout(timeout);\n        if (curTime - start >= threshold) {\n            //只执行一部分方法，这些方法是在某个时间段内执行一次\n            fn.apply(context, args);\n            start = curTime;\n        }\n        else {\n            //让方法在脱离事件后也能执行一次\n            timeout = window.setTimeout(() => {\n                //@ts-ignore\n                fn.apply(this, args);\n            }, threshold);\n        }\n    };\n}\n\nconst eventMap = new Map<HTMLElement, Dragger>();\n\nconst defaultOptions = {\n    inViewport: true\n}\n\nclass Dragger {\n\n    private _trigger: HTMLElement = null;\n    private _container: HTMLElement = null;\n    private _options: any = null;\n    private _state: any = null;\n    private _isFirst: boolean = true;\n    private _style: string = null;\n\n    constructor(trigger: HTMLElement, container: HTMLElement, dragInViewport: boolean) {\n        this._trigger = trigger;\n        this._container = container;\n        this._options = Object.assign({}, defaultOptions, {\n            inViewport: dragInViewport\n        });\n        this._state = {\n            isInDrag: false,\n            mX: 0, // mouse x\n            mY: 0, // mouse y\n            domStartX: 0, // on mousedown, the mouse x\n            domStartY: 0, // on mousedown, the mouse y            \n        }\n    }\n\n    getContainerPos() {\n        const rect = this._container.getBoundingClientRect();\n        return {\n            left: rect.left,\n            top: rect.top\n        }\n    }\n\n    onMousedown = (e) => {\n        const state = this._state;\n        state.isInDrag = true;\n        state.mX = e.clientX;\n        state.mY = e.clientY;\n        this._container.style.position = \"absolute\";\n        const { left, top } = this.getContainerPos();\n\n        if (this._isFirst) {\n\n            state.domMaxY = document.documentElement.clientHeight\n                - this._container.offsetHeight - 1;\n            state.domMaxX = document.documentElement.clientWidth\n                - this._container.offsetWidth - 1;\n            state.domMaxY = state.domMaxY < 0 ? 0 : state.domMaxY;\n            state.domMaxX = state.domMaxX < 0 ? 0 : state.domMaxX;\n\n            this._container.style.left = left + 'px';\n            this._container.style.top = top + 'px';\n\n            if (!this._style) {\n                this._style = this._container.getAttribute(\"style\");\n            }\n\n            this._isFirst = false;\n        }\n\n        state.domStartX = left;\n        state.domStartY = top;\n    }\n\n    onMouseup = (e) => {\n        const state = this._state;\n\n        state.isInDrag = false;\n\n        const { left, top } = this.getContainerPos();\n        state.domStartX = left;\n        state.domStartY = top;\n    }\n\n    onMousemove = throttle((e) => {\n        const state = this._state;\n        if (state.isInDrag) {\n            var nowX = e.clientX,\n                nowY = e.clientY,\n                disX = nowX - state.mX,\n                disY = nowY - state.mY;\n\n            var newDomX = state.domStartX + disX;\n            var newDomY = state.domStartY + disY;\n            if (this._options.inViewport) {\n                if (newDomX < 0) {\n                    newDomX = 0;\n                }\n                else if (newDomX > state.domMaxX) {\n                    newDomX = state.domMaxX;\n                }\n                if (newDomY < 0) {\n                    newDomY = 0;\n                }\n                else if (newDomY > state.domMaxY) {\n                    newDomY = state.domMaxY;\n                }\n            }\n            this._container.style.position = \"absolute\";\n            this._container.style.margin = \"0\";\n            this._container.style.paddingBottom = \"0\";\n            this._container.style.left = newDomX + \"px\";\n            this._container.style.top = newDomY + \"px\";\n        }\n    }, 10).bind(this);\n\n    onResize = throttle((e) => {\n        const state = this._state;\n\n        state.domMaxY = document.documentElement.clientHeight\n            - this._container.offsetHeight - 1;\n        state.domMaxX = document.documentElement.clientWidth\n            - this._container.offsetWidth - 1;\n        state.domMaxY = state.domMaxY < 0 ? 0 : state.domMaxY;\n        state.domMaxX = state.domMaxX < 0 ? 0 : state.domMaxX;\n        state.domStartY = parseInt(this._container.style.top);\n        state.domStartX = parseInt(this._container.style.left);\n        if (state.domStartY > state.domMaxY) {\n            if (state.domMaxY > 0) {\n                this._container.style.top = state.domMaxY + \"px\";\n            }\n        }\n        if (state.domStartX > state.domMaxX) {\n            this._container.style.left = state.domMaxX + \"px\";\n        }\n    }, 10).bind(this);\n\n    bindDrag() {\n        const trigger = this._trigger;\n        const options = this._options;\n\n        trigger.addEventListener(\"mousedown\", this.onMousedown, false);\n        window.addEventListener(\"mouseup\", this.onMouseup, false);\n        document.addEventListener(\"mousemove\", this.onMousemove);\n        if (options.inViewport) {\n            window.addEventListener(\"resize\", this.onResize, false);\n        }\n    }\n\n    unbindDrag() {\n        const trigger = this._trigger;\n\n        trigger.removeEventListener(\"mousedown\", this.onMousedown, false);\n        window.removeEventListener(\"mouseup\", this.onMouseup, false);\n        document.removeEventListener(\"mousemove\", this.onMousemove);\n        if (this._options.inViewport) {\n            window.removeEventListener(\"resize\", this.onResize, false);\n        }\n    }\n\n    resetContainerStyle() {\n        if (this._style !== null) {\n            this._isFirst = true;\n            this._container.setAttribute(\"style\", this._style);\n        }\n    }\n}\n\nfunction enableDraggable(trigger: HTMLElement, container: HTMLElement, dragInViewport: boolean = true) {\n    let dragger = eventMap.get(trigger);\n    if (!dragger) {\n        dragger = new Dragger(trigger, container, dragInViewport);\n        eventMap.set(trigger, dragger);\n    } \n    dragger.bindDrag();\n}\n\nfunction disableDraggable(trigger: HTMLElement) {\n    const dragger = eventMap.get(trigger);\n    if (dragger) {\n        dragger.unbindDrag();\n    }\n}\n\nfunction resetModalPosition(trigger: HTMLElement) {\n    const dragger = eventMap.get(trigger);\n    if (dragger) {\n        dragger.resetContainerStyle();\n    }\n}\n\nexport { enableDraggable, disableDraggable, resetModalPosition };","﻿import { domInfoHelper } from './exports';\nimport { state } from '../stateProvider';\n\nexport class eventHelper {\n  static triggerEvent(element: HTMLInputElement, eventType: string, eventName: string) {\n    //TODO: replace with event constructors https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n    //Not used \n    const evt = document.createEvent(eventType);\n    evt.initEvent(eventName);\n    return element.dispatchEvent(evt);\n  }\n\n  static addDomEventListener(element, eventName: string, preventDefault: boolean, invoker: any) {\n    const callback = args => {\n      const obj = {};\n      for (let k in args) {\n        if (k !== 'originalTarget') { //firefox occasionally raises Permission Denied when this property is being stringified\n          obj[k] = args[k];\n        }\n      }\n      const json = JSON.stringify(obj, (k, v) => {\n        if (v instanceof Node) return 'Node';\n        if (v instanceof Window) return 'Window';\n        return v;\n      }, ' ');\n      setTimeout(function () { invoker.invokeMethodAsync('Invoke', json) }, 0);\n      if (preventDefault === true) {\n        args.preventDefault();\n      }\n    };\n\n    if (element === 'window') {\n      if (eventName === 'resize') {\n        window.addEventListener(eventName, this.debounce(() => callback({ innerWidth: window.innerWidth, innerHeight: window.innerHeight }), 200, false));\n      } else {\n        window.addEventListener(eventName, callback);\n      }\n    } else {\n      const dom = domInfoHelper.get(element);\n      if (dom) {\n        (dom as HTMLElement).addEventListener(eventName, callback);\n      }\n    }\n  }  \n\n  static addDomEventListenerToFirstChild(element, eventName, preventDefault, invoker) {\n    const dom = domInfoHelper.get(element);\n\n    if (dom && dom.firstElementChild) {\n      this.addDomEventListener(dom.firstElementChild, eventName, preventDefault, invoker);\n    }\n  }\n\n  static addPreventKeys(inputElement, keys: string[]) {\n    if (inputElement) {\n      const dom = domInfoHelper.get(inputElement);\n      keys = keys.map(function (x) { return x.toUpperCase(); })\n      state.eventCallbackRegistry[inputElement.id + \"keydown\"] = (e) => this.preventKeys(e, keys);\n      (dom as HTMLElement).addEventListener(\"keydown\", state.eventCallbackRegistry[inputElement.id + \"keydown\"], false);\n    }\n  }\n\n  static preventKeyOnCondition(e: KeyboardEvent, key: string, check: () => boolean) {\n    if (e.key.toUpperCase() === key.toUpperCase() && check()) {\n      e.preventDefault();\n      return false;\n    }\n  }\n\n  static removePreventKeys(inputElement) {\n    if (inputElement) {\n      const dom = domInfoHelper.get(inputElement);\n      if (dom) {\n        (dom as HTMLElement).removeEventListener(\"keydown\", state.eventCallbackRegistry[inputElement.id + \"keydown\"]);\n        state.eventCallbackRegistry[inputElement.id + \"keydown\"] = null;\n      }\n    }\n  }\n\n  private static debounce(func, wait, immediate) {\n    var timeout;\n    return () => {\n      const context = this, args = arguments;\n      const later = () => {\n        timeout = null;\n        if (!immediate) func.apply(this, args);\n      };\n      const callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  };\n\n  private static preventKeys(e: KeyboardEvent, keys: string[]) {\n    if (keys.indexOf(e.key.toUpperCase()) !== -1) {\n      e.preventDefault();\n      return false;\n    }\n  }\n}","﻿export { infoHelper as domInfoHelper } from './infoHelper';\nexport { manipulationHelper as domManipulationHelper } from './manipulationHelper';\nexport { eventHelper } from './eventHelper';\nexport * as domTypes from './types';","﻿import { domTypes } from './exports'\n\nexport class infoHelper {\n  static getWindow() {\n    return {\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight\n    };\n  }\n\n  static get(element: any) {\n    if (!element) {\n      element = document.body;\n    } else if (typeof element === 'string') {\n      if (element === 'document') {\n        return document;\n      }\n      element = document.querySelector(element!)\n    }\n    return element;\n  }\n\n  static getInfo(element: any): domTypes.domInfo {\n    let domElement = this.get(element);\n    if (!domElement) {\n      domElement = {};\n    }\n    const absolutePosition = this.getElementAbsolutePos(domElement);\n    const result: domTypes.domInfo = {\n      offsetTop: domElement.offsetTop || 0,\n      offsetLeft: domElement.offsetLeft || 0,\n      offsetWidth: domElement.offsetWidth || 0,\n      offsetHeight: domElement.offsetHeight || 0,\n      scrollHeight: domElement.scrollHeight || 0,\n      scrollWidth: domElement.scrollWidth || 0,\n      scrollLeft: domElement.scrollLeft || 0,\n      scrollTop: domElement.scrollTop || 0,\n      clientTop: domElement.clientTop || 0,\n      clientLeft: domElement.clientLeft || 0,\n      clientHeight: domElement.clientHeight || 0,\n      clientWidth: domElement.clientWidth || 0,\n      selectionStart: domElement.selectionStart || 0,\n      absoluteTop: Math.round(absolutePosition.y),\n      absoluteLeft: Math.round(absolutePosition.x)\n    };\n    return result;\n  }\n\n  static getElementAbsolutePos(element: any): domTypes.position {\n    const res: domTypes.position = {\n      x: 0,\n      y: 0\n    };\n    if (element !== null) {\n      if (element.getBoundingClientRect) {\n        const viewportElement = document.documentElement;\n        const box = element.getBoundingClientRect();\n        const scrollLeft = viewportElement.scrollLeft;\n        const scrollTop = viewportElement.scrollTop;\n\n        res.x = box.left + scrollLeft;\n        res.y = box.top + scrollTop;\n      }\n    }\n    return res;\n  }\n\n  static getBoundingClientRect(element: any): domTypes.domRect {\n    const domElement = this.get(element);\n    if (domElement && domElement.getBoundingClientRect) {\n      const rect = domElement.getBoundingClientRect();\n      // Fixes #1468. This wrapping is necessary for old browsers. Remove this when one day we no longer support them.\n      return {\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        x: rect.x,\n        y: rect.y\n      };\n    }\n    return null;\n  }\n\n  static getFirstChildDomInfo(element: any) {\n    const domElement = this.get(element);\n    if (domElement) {\n      if (domElement.firstElementChild) {\n        return this.getInfo(domElement.firstElementChild);\n      } else {\n        return this.getInfo(domElement);\n      }\n    }\n    return null;\n  }\n\n  static getActiveElement() {\n    const element = document.activeElement;\n    const id = element.getAttribute(\"id\") || \"\";\n    return id;\n  }\n\n  static getScroll() {\n    return { x: window.pageXOffset, y: window.pageYOffset };\n  }\n\n  static hasFocus(selector) {\n    const dom = this.get(selector);\n    return (document.activeElement === dom);\n  }\n\n  static getInnerText(element) {\n    const dom = this.get(element);\n    if (dom) return dom.innerText;\n    return null;\n  }\n\n  static getMaxZIndex(): number {\n    return [...document.querySelectorAll(\"*\")].reduce((r, e) => Math.max(r, +window.getComputedStyle(e).zIndex || 0), 0)\n  }  \n\n  static isFixedPosition(element) {\n    let node = this.get(element);\n    while (node && node.nodeName.toLowerCase() !== 'body') {\n        if (window.getComputedStyle(node).getPropertyValue('position').toLowerCase() === 'fixed')\n            { return true; }\n        node = node.parentNode;\n    }\n    return false;\n  }\n  \n  static findAncestorWithZIndex(element: HTMLElement): number {\n    let node = this.get(element);\n    let zIndexAsString: string;\n    let zIndex: number;\n    while (node && node.nodeName.toLowerCase() !== 'body') {\n        zIndexAsString = window.getComputedStyle(node).zIndex;\n        zIndex = Number.parseInt(zIndexAsString);\n        if (!Number.isNaN(zIndex)) {\n           return zIndex;\n        }\n        node = node.parentNode;\n    }\n    return null;\n  }\n\n}","﻿import { domInfoHelper } from './exports'\nimport { styleHelper } from '../styleHelper'\nimport { state } from '../stateProvider'\nimport * as enums from '../enums';\n\nexport class manipulationHelper {\n  static addElementToBody(element) {\n    document.body.appendChild(element);\n  }\n\n  static delElementFromBody(element) {\n    document.body.removeChild(element);\n  }\n\n  static addElementTo(addElement, elementSelector): boolean {\n    let parent = domInfoHelper.get(elementSelector);\n    if (parent && addElement) {\n      if (parent instanceof Node && addElement instanceof Node) {\n        parent.appendChild(addElement);\n        return true;\n      } else {\n        console.log(\"does not implement node\", parent, addElement);\n      }\n    }\n    return false;\n  }\n\n  static delElementFrom(delElement, elementSelector) {\n    let parent = domInfoHelper.get(elementSelector);\n    if (parent && delElement) {\n      parent.removeChild(delElement);\n    }\n  }\n\n  static setDomAttribute(element, attributes) {\n    let dom: HTMLElement = domInfoHelper.get(element);\n    if (dom) {\n      for (let key in attributes) {\n        dom.setAttribute(key, attributes[key]);\n      }\n    }\n  }\n\n  static copy(text) {\n    if (!navigator.clipboard) {\n      this.fallbackCopyTextToClipboard(text);\n      return;\n    }\n    navigator.clipboard.writeText(text).then(function () {\n      console.log('Async: Copying to clipboard was successful!');\n    }, function (err) {\n      console.error('Async: Could not copy text: ', err);\n    });\n  }\n\n  private static fallbackCopyTextToClipboard(text) {\n    var textArea = document.createElement(\"textarea\");\n    textArea.value = text;\n\n    // Avoid scrolling to bottom\n    textArea.style.top = \"0\";\n    textArea.style.left = \"0\";\n    textArea.style.position = \"fixed\";\n\n    document.body.appendChild(textArea);\n    textArea.focus();\n    textArea.select();\n\n    try {\n      var successful = document.execCommand('copy');\n      var msg = successful ? 'successful' : 'unsuccessful';\n      console.log('Fallback: Copying text command was ' + msg);\n    } catch (err) {\n      console.error('Fallback: Oops, unable to copy', err);\n    }\n\n    document.body.removeChild(textArea);\n  }\n\n  static focus(selector, noScroll: boolean = false, option: enums.FocusBehavior = enums.FocusBehavior.FocusAtLast) {\n    let dom = domInfoHelper.get(selector);\n    if (!(dom instanceof HTMLElement))\n      throw new Error(\"Unable to focus on invalid element.\");\n\n    dom.focus({\n      preventScroll: noScroll\n    });\n\n    if (dom instanceof HTMLInputElement || dom instanceof HTMLTextAreaElement) {\n      switch (option) {\n        case enums.FocusBehavior.FocusAndSelectAll:\n          dom.select();\n          break;\n        case enums.FocusBehavior.FocusAtFirst:\n          dom.setSelectionRange(0, 0);\n          break;\n        case enums.FocusBehavior.FocusAtLast:\n          dom.setSelectionRange(-1, -1);\n          break;\n      }\n    }\n  }\n\n\n  static blur(selector) {\n    let dom = domInfoHelper.get(selector);\n    if (dom) {\n      dom.blur();\n    }\n  }\n\n  static scrollTo(selector: Element | string, parentElement?: HTMLElement) {\n    const element = domInfoHelper.get(selector);\n    if (parentElement && element && element instanceof HTMLElement) {\n      parentElement.scrollTop = element.offsetTop;\n    } else if (element && element instanceof HTMLElement) {\n        element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });\n    }    \n  }  \n\n  static slideTo(targetPageY) {\n    const timer = setInterval(function () {\n      const currentY = document.documentElement.scrollTop || document.body.scrollTop;\n      const distance = targetPageY > currentY ? targetPageY - currentY : currentY - targetPageY;\n      const speed = Math.ceil(distance / 10);\n      if (currentY === targetPageY) {\n        clearInterval(timer);\n      } else {\n        window.scrollTo(0, targetPageY > currentY ? currentY + speed : currentY - speed);\n      }\n    }, 10);\n  }\n\n  //copied from https://www.telerik.com/forums/trigger-tab-key-when-enter-key-is-pressed\n  static invokeTabKey() {\n    var currInput = document.activeElement;\n    if (currInput.tagName.toLowerCase() == \"input\") {\n      var inputs = document.getElementsByTagName(\"input\");\n      var currInput = document.activeElement;\n      for (var i = 0; i < inputs.length; i++) {\n        if (inputs[i] == currInput) {\n          var next = inputs[i + 1];\n          if (next && next.focus) {\n            next.focus();\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  static disableBodyScroll() {\n    let body = document.body;\n    const oldBodyCache = {};\n    [\"position\", \"width\", \"overflow\"].forEach((key) => {\n      oldBodyCache[key] = body.style[key];\n    });\n    state.oldBodyCacheStack.push(oldBodyCache);\n    styleHelper.css(body,\n      {\n        \"position\": \"relative\",\n        \"width\": this.hasScrollbar() ? \"calc(100% - 17px)\" : null,\n        \"overflow\": \"hidden\"\n      });\n    styleHelper.addCls(document.body, \"ant-scrolling-effect\");\n  }\n\n  static enableBodyScroll() {\n    let oldBodyCache = state.oldBodyCacheStack.length > 0 ? state.oldBodyCacheStack.pop() : {};\n\n    styleHelper.css(document.body,\n      {\n        \"position\": oldBodyCache[\"position\"] ?? null,\n        \"width\": oldBodyCache[\"width\"] ?? null,\n        \"overflow\": oldBodyCache[\"overflow\"] ?? null\n      });\n    styleHelper.removeCls(document.body, \"ant-scrolling-effect\");\n  }\n\n  static hasScrollbar = () => {\n    let overflow = document.body.style.overflow;\n    if (overflow && overflow === \"hidden\") return false;\n    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);\n  }\n\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==","﻿export enum FocusBehavior {\n  /// <summary>\n  /// When focuses, cursor will move to the last character. \n  /// This is default behavior.\n  /// </summary>\n  FocusAtLast,\n  /// <summary>\n  /// When focuses, cursor will move to the first character\n  /// </summary>\n  FocusAtFirst,\n  /// <summary>\n  /// When focuses, the content will be selected\n  /// </summary>\n  FocusAndSelectAll\n}","﻿import { eventCallback } from './dom/types'\n\n//Singleton \nexport class State {\n  private static instance: State;\n\n  //Stores references to dot net objects (components wrapped in DotNetObjectReference)\n  objReferenceDict: { [key: string]: any } = {};\n\n  //All object references must later be disposed by JS code or by .NET code.\n  disposeObj(objReferenceName) {\n    delete this.objReferenceDict[objReferenceName];\n  }\n\n  //Stores callback for events based on a key. Needed when\n  //Event needs to be removed - the callback can be retrieved and\n  //used to remove the event in question\n  eventCallbackRegistry: { [key: string]: eventCallback} = {};\n  \n  oldBodyCacheStack = [];\n\n  private constructor() { }\n\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new State();      \n    }\n    return this.instance;\n  }\n}\n\nexport const state = State.getInstance();","﻿import { infoHelper as domInfoHelper } from './dom/infoHelper';\n\nexport class styleHelper {\n  static addCls(selector: Element | string, className: string | Array<string>) {\n    let element = domInfoHelper.get(selector);\n    if (element) {\n      if (typeof className === \"string\") {\n        element.classList.add(className);\n      } else {\n        element.classList.add(...className);\n      }\n    }\n  }\n\n  static removeCls(selector: Element | string, clsName: string | Array<string>) {\n    let element = domInfoHelper.get(selector);\n    if (element) {\n      if (typeof clsName === \"string\") {\n        element.classList.remove(clsName);\n      } else {\n        element.classList.remove(...clsName);\n      }\n    }\n  }\n\n  static addClsToFirstChild(element: Element | string, className: string): void {\n    var domElement = domInfoHelper.get(element);\n    if (domElement && domElement.firstElementChild) {\n      domElement.firstElementChild.classList.add(className);\n    }\n  }\n\n  static removeClsFromFirstChild(element: Element | string, className): void {\n    var domElement = domInfoHelper.get(element);\n    if (domElement && domElement.firstElementChild) {\n      domElement.firstElementChild.classList.remove(className);\n    }\n  }\n\n  static matchMedia(query: string): boolean {\n    return window.matchMedia(query).matches;\n  }\n\n  static getStyle(element, styleProp: string) {\n    if (element.currentStyle)\n      return element.currentStyle[styleProp];\n    else if (window.getComputedStyle)\n      return document.defaultView.getComputedStyle(element, null).getPropertyValue(styleProp);\n  }\n\n  //Referenced in Caret, class Mirror\n  static css(element: HTMLElement, name: string | object, value: string | null = null) {\n    if (typeof name === 'string') {\n      if (value === null) {\n        let style = name;\n        let cssAttributes = style.split(\";\");\n        for (let i = 0; i < cssAttributes.length; i++) {\n          let cssAttribute = cssAttributes[i];\n          if (!cssAttribute) continue;\n          let attribute = cssAttribute.split(\":\");\n          element.style.setProperty(attribute[0], attribute[1]);\n        }\n        return;\n      }\n      element.style.setProperty(name, value);\n    } else {\n      for (let key in name) {\n        if (name.hasOwnProperty(key)) {\n          element.style.setProperty(key, name[key]);\n        }\n      }\n    }\n  }\n}","﻿import * as interop from \"./core/JsInterop/interop\";\n\ndeclare global {\n  interface Window {\n    AntDesign: any;\n  }\n}\n\nwindow.AntDesign = {\n  interop,\n};\n"]}